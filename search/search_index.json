{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":""},{"location":"#hypercubing-developers","title":"Hypercubing Developers","text":"<p>Welcome! If you are not a puzzle designer or software developer, see https://hypercubing.xyz/ for general hypercubing info.</p> <p>If you want to build your own twisty puzzles or understand twisty puzzle software, you're in the right place! Read Prerequisites first, then dive into whatever tutorial series you're interested in.</p> <p>If you understand the stuff on this wiki, you should absolutely join the Hypercubers Discord server:</p>"},{"location":"prereqs/","title":"Prerequisites","text":"<p>All content on this wiki assumes that you're familiar with basic linear algebra and have some geometric intuition. In particular, you should be comfortable with:</p> <ul> <li>vectors as a representation of directions and points in 2D and 3D space</li> <li>matrices as a representation of linear transformations</li> <li>the determinant as a representation of signed area/volume</li> </ul> <p>3Blue1Brown's Essense of Linear Algebra series is an excellent primer.</p> <p>Additionally, much of the puzzle-related content on this wiki assumes you are comfortable with 3D and 4D twisty puzzles and have some intuitive grasp of spherical and hyperbolic space. If you're able to solve these puzzles, then you're ready:</p> <ul> <li>3<sup>3</sup></li> <li>3<sup>4</sup></li> <li>any hyperbolic puzzle in MagicTile (e.g., \"Hyperbolic Rubik\")</li> <li>any Euclidean puzzle in MagicTile (e.g., \"Torus Rubik\")</li> <li>any spherical puzzle in MagicTile (e.g., \"Rubik's Cube\")</li> </ul>"},{"location":"hsc/conventions/piece-types/","title":"Piece types","text":"<p>How to name piece types for an HSC2 puzzle.</p> <p>Warning</p> <p>This is a draft</p> <p>In general, piece types should be based on ther geometric layout, rather than being based on a particular solution method or solving order. This system was chosen so the piece names are neutral relative to the solution.</p> <p>A piece that is at the center of the puzzle should be called a core. However, if this piece is not fixed, like in the &lt;Rw, Uw&gt; 3\u00d73, it can have another name, such as anticore. A piece that is at the center of a facet of the puzzle should be called a center. A piece that is at the center of another element of the puzzle should be named after that element, i.e. corner, edge, or ridge, as in the 3<sup>n</sup>.</p> <p>A piece that is not at the center of an element of the puzzle lies between the centers of some nearby elements that are all incident. The piece should be in the top-level group named after a piece centered at the highest-rank element of that subflag. That name should be prefixed by letters corresponding to the other elements of the subflag by increasing rank, where corner is V, edge is E, and ridge is R, except that a V-edge is called a wing. In 3 dimensions, V-center is replaced by X-center and E-center is replaced by T-center. If the subflag is a flag, it is called an oblique. Obliques can have two chiralities that depend on the sign of the determinant of the matrix whose rows are the centers of the elements by increasing rank: if it is positive, the piece is an oblique (right), and otherwise it is an oblique (left).</p> <p>If multiple pieces have the same name, they should be disambiguated with adjectives. These can include inner and outer (as in the elite pentultimate's X-centers), pentagonal and hexagonal (as in the Tuttminx), big and small, or numbers (as in large N<sup>3</sup> puzzles).</p> <p>If an orbit of indistinguishable pieces occupies multiple positions, it can be given a name from outside of this system (as in the bagua cube's triangles, which can be both X-centers and T-centers). Exceptions can be made to this system for sufficiently compelling reasons, such as shapemods where the outer geometry does not match the axis system (like the hexaminx), or puzzles with established piece names (such as the face-turning octahedron's triangles).</p>"},{"location":"hsc/conventions/versions/","title":"Puzzle versions","text":"<p>Soon</p>"},{"location":"hsc/internals/","title":"Hyperspeedcube Internals","text":"<p>Warning</p> <p>You may need to refresh each page once in order to ensure that the math equations load.</p>"},{"location":"hsc/internals/#hyperspeedcube-internals","title":"Hyperspeedcube Internals","text":"<p>The goal of this tutorial series is to explain the entirety of the Hyperspeedcube puzzle engine, including construction and simulation. It proritizes geometric intuition for the mathematics and algorithms involved, but doesn't provide formal proofs. Especially in the earlier chapters, you'll just have to believe me that the math works the way it does.</p> <p>This series is meant to be read in order; if you don't understand something, try rereading earlier pages until they make sense. If it still doesn't make sense after rereading, ping me (@HactarCE or @Hyperspeedcube Developer) on the Hypercubers Discord server.</p> <p>There are occasional exercises throughout. Even for a casual read, I highly recommend completing these exercises; they're designed to take very little time and will massively improve your understanding of the material.</p> <p>Read Prequisites first to make sure you have the prerequisite knowledge.</p>"},{"location":"hsc/internals/#code-structure","title":"Code structure","text":"<p>Hyperspeedcube is split into four crates, each depending on the previous ones:</p> <ul> <li><code>hypermath</code> - mathematical primitives (vectors, matrixes, CGA multivectors, and some data structures)</li> <li><code>hypershape</code> - shape slicing algorithms</li> <li><code>hyperpuzzle</code> - Lua API and any algorithms that are relevant particularly to twisty puzzles</li> <li><code>hyperspeedcube</code> - user interface</li> </ul> <p>This tutorial series describes how the first three crates work. The <code>hyperspeedcube</code> crate contains typical UI code and doesn't particularly need external documentation.</p>"},{"location":"hsc/internals/#roadmap","title":"Roadmap","text":"<p>Hyperspeedcube makes heavy use of an algebraic system called Conformal Geometric Algebra (CGA). In order to understand CGA, you must first understand Projective Geometric Algebra (PGA), which in turn relies on an understanding of Vectorspace Geometric Algebra (VGA).</p> <p>Once we have established a solid understanding of CGA, we'll cover the representation of conformal polytopes and various algorithms we can do using them, culminating in the shape slicing algorithm.</p> <p>After that, we'll define patchwork spaces and extend the shape slicing algorithm to work in those.</p>"},{"location":"hsc/internals/cga/","title":"Conformal GA","text":"<p>This page is incomplete</p> <p>PGA added one new basis vector and unlocked projective geometry. CGA (Conformal Geometric Algebra) takes this to the extreme: by adding two new basis vectors \\(e_-\\) and \\(e_+\\), we can represent circles, spheres, and arbitrary conformal transformations, which unifies hyperbolic, spherical, and Euclidean space. CGA is incredibly powerful.</p>"},{"location":"hsc/internals/cga/#conformal-sphere","title":"Conformal sphere","text":""},{"location":"hsc/internals/cga/#points-lines-circles-planes-and-spheres","title":"Points, lines, circles, planes, and spheres","text":""},{"location":"hsc/internals/cga/#conformal-transformations","title":"Conformal transformations","text":""},{"location":"hsc/internals/pga/","title":"Projective GA","text":"<p>VGA gives us the tools to represent vectors, planes, etc. that intersect the origin, and rotations/reflections around the origin. PGA (Projective Geometric Algebra) adds a new basis vector \\(w\\), and uses it to represent points, lines, and planes anywhere in Euclidean space<sup>1</sup>, and any isometry of Euclidean space.</p> <p>What is an isometry?</p> <p>An isometry is a distance-preserving transformation. (The word \"isometry\" literally means \"same measure.\") In Euclidean space, this is some combination of translations, rotations, and reflections.</p> <p>Is \\(w\\) the  fourth dimension ?</p> <p>No, we're not talking about 4D space yet. \\(w\\) is not an ordinary spatial dimension, it's just an algebraic tool. Everything discussed here can be generalized to any number of dimensions.</p>"},{"location":"hsc/internals/pga/#projective-plane","title":"Projective plane","text":"<p>In projective GA, we keep \\(x^2 = y^2 = z^2 = 1\\). But our new basis vector \\(w\\) is a null vector, which means it squares to zero: \\(w^2 = 0\\). Let's stick to 2D for now, so that we only have three basis vectors: \\(x\\), \\(y\\), and \\(w\\).</p>"},{"location":"hsc/internals/pga/#points-lines-and-planes","title":"Points, lines, and planes","text":"<p>PGA gives us the ability to represent a point as a vector. A point at coordinates \\(\\langle a, b \\rangle\\) is represented with the vector \\(ax + by + w\\). The origin \\(\\langle 0, 0 \\rangle\\) is represented with the vector \\(w\\). These vectors can be scaled arbitrarily and still represent the same point. For example, these blades all represent \\(\\langle 2, -1 \\rangle\\):</p> <ul> <li>\\(2x-y+w\\)</li> <li>\\(-2x+y-w\\)</li> <li>\\(10x-5y+5w\\)</li> </ul> <p>This gives the geometry of the projective plane (or in general, a projective space), where we have all the finite points \\(\\langle x, y \\rangle\\) plus a line at infinity that can be reached by traveling infinitely far in any direction. (In 3D+, I like to think of it as half of a skybox.) Points on the line at infinity are represented using vectors with zero \\(w\\) component, such as \\(-3x+2y\\).</p> <p>Projective geometry</p> <p>The projective plane has some nice properties:</p> <ul> <li>Every pair of distinct points has exactly one line passing through both.</li> <li>Every pair of lines intersects at exactly one point, even if they are parallel.</li> </ul> <p>Here's some examples of how this works:</p> <ul> <li>Given two points \\(p\\) and \\(q\\) represented using vectors, \\(p \\wedge q\\) is the line containing \\(p\\) and \\(q\\). Iff<sup>2</sup> \\(p\\) and \\(q\\) are the same point, then \\(p \\wedge q = 0\\).</li> <li>Given a line \\(l\\) represented using a bivector and a point \\(p\\) represented using a vector, \\(l \\wedge p\\) is the plane containing \\(l\\) and \\(p\\). Iff \\(p\\) is already on \\(l\\), then \\(l \\wedge p = 0\\).</li> </ul> <p>In general, any blade \\(C_r\\) intersects the projective plane \\(w=1\\) at an \\((r-1)\\)-dimensional subspace \\(S\\), so we say that \\(C_r\\) represents \\(S\\). If \\(C_r\\) has no \\(w\\) component, we say it represents a subspace at infinity. (In 2D, that's the line at infinity or a point at infinity.)</p> <p>The sign of a blade indicates the orientation of the subspace. So \\(-C_r\\) represents the same \\(r\\)-dimensional subspace as \\(C_r\\), but with the opposite orientation. Orientation will be very important later on.</p>"},{"location":"hsc/internals/pga/#outer-product","title":"Outer product","text":"<p>The outer product works here too: The outer product \\(C_r \\wedge D_s\\) gives the representation of the unique \\((r+s-1)\\)-dimensional subspace containing \\(C_r\\) and \\(D_s\\). If \\(C_r\\) and \\(D_s\\) are in the same \\((r+s-2)\\)-dimensional subspace, then there isn't a unique \\((r+s-1)\\)-dimensional subspace containing them, so \\(C_r \\wedge D_s = 0\\).</p>"},{"location":"hsc/internals/pga/#which-side","title":"Which side?","text":"<p>We can use this to check if a point \\(p\\) is contained in a subspace \\(C_r\\): just check whether \\(C_r \\wedge p\\) is zero. In \\(N\\)-dimensional space, we can check which side of a hyperplane \\(H\\) (represented as an \\(N\\)-blade) contains \\(p\\) by computing \\(C_r \\wedge p\\), which gives a single pseudoscalar component whose sign is positive if \\(p\\) is on one side of \\(C_r\\) and negative if it's on the other side. To get a scalar, we take the dual: \\((C_r \\wedge p) \\rfloor I\\). Note that negating either \\(p\\) or \\(C_r\\) negates the sign of the result.</p> <p>We can generalize this to work in subspaces as well: If \\(C_r\\) is a subspace of \\(D_{r+1}\\), then the sign of the scalar \\((C_r \\wedge p) \\rfloor D_{r+1}\\) indicates which side of \\(C_r\\) contains \\(p\\). Note that negating either \\(p\\), \\(C_r\\), or \\(D_{r+1}\\) negates the sign of the result.</p> <p>Exercise</p> <p>Think about smooth transformations of a point \\(p\\), a line \\(C_1\\), and a plane \\(D_2\\) such that \\(p\\) and \\(C_1\\) stay in \\(D_2\\) but \\(p\\) ends up on the other side of \\(C_1\\). By the intermediate value theorem, the sign of \\((C_r \\wedge p) \\rfloor D_s\\) can only change when \\(p\\) touches \\(C_1\\), so the sign is the same. But \\(p\\) is on the same side of \\(C_1\\). How did this happen?</p> Answer <p>In order to get \\(p\\) to the other side of \\(C_r\\), \\(D_s\\) got flipped over and changed sign.</p> <p>This pattern of replacing the pseudoscalar with another blade to simulate lower-dimensional environments will show up a lot.</p>"},{"location":"hsc/internals/pga/#motors-and-flectors","title":"Motors and flectors","text":"<p>Remember rotors, our friends from the even subalgebra of VGA? They've gotten an upgrade in PGA: they're now called motors and can represent arbitrary translations in addition to rotations! And of course we have flectors, which use the odd subalgebra and represent any combination of translations, rotations, and an odd number of reflections. You can use them exactly the same way you use rotors.</p> <ol> <li> <p>Actually, anywhere in projective space, which is a superset of Euclidean space!\u00a0\u21a9</p> </li> <li> <p>\"iff\" is short for if and only if.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/internals/slicing/","title":"Slicing Shapes","text":"<p>This page is incomplete</p>"},{"location":"hsc/internals/vga/","title":"Vectorspace GA","text":"<p>Complex numbers are a system where each number has two components: real and imaginary. Geometric Algebra is like complex numbers, but adds way more components.<sup>1</sup> For example, 3D VGA (Vectorspace Geometric Algebra or Vanilla Geometric Algebra) adds seven extra components a total of eight.</p>"},{"location":"hsc/internals/vga/#multivectors","title":"Multivectors","text":"<p>All geometric algebra systems have scalars, the ordinary positive and negative numbers you know and love. In 3D VGA, we also have vector components \\(x\\), \\(y\\), and \\(z\\), and we can build vectors out of them. For example, \\(x-7z\\) represents the vector \\(\\langle 1, 0, -7 \\rangle\\). Just like a complex number has both real and imaginary components (e.g., \\(3+2i\\)), a multivector represented in VGA can have both scalar and vector components (e.g., \\(5+3x+y-2z\\)). Each of these components is a term</p> <p>You might recognize this as a vector space, which just means that addition, subtraction, and scalar multiplication all work how you expect. But 3D VGA isn't actually a 3D vector space, because we have \\(1\\), the unit scalar, as a fourth basis vector, orthogonal to \\(x\\), \\(y\\), and \\(z\\). Don't worry, you can still visualize it using just three dimensions by treating the scalar component as separate.</p> <p>Confusing terminology</p> <p>A \"multivector\" is any element of the vector space, while a \"vector\" in GA consists of only vector components, like \\(2x-y\\) (but not \\(4+2x-y\\)). But the term \"basis vector\" applies in the vector space as a whole, so \\(1\\), \\(x\\), \\(y\\), and \\(z\\) are all basis vectors.</p> <p>So we have four basis vectors: \\(1\\), \\(x\\), \\(y\\), and \\(z\\). But earlier I said that 3D VGA actually has eight basis vectors. How do we get all those extra basis vectors?</p>"},{"location":"hsc/internals/vga/#geometric-product","title":"Geometric product","text":"<p>Conventions</p> <ul> <li>\\(a\\), \\(b\\), \\(c\\), \\(d\\) are arbitrary vectors</li> <li>\\(A\\), \\(B\\), \\(C\\), \\(D\\) are arbitrary multivectors</li> </ul> <p>The geometric product is how we generalize multiplication to work on multivectors. We write it using ordinary multiplication, so \\(AB\\) is the geometric product of \\(A\\) and \\(B\\). In code, the geometric product of <code>a</code> and <code>b</code> is written <code>a * b</code>. For scalars, it does what you expect. The geometric product has some nice properties:</p> <ul> <li> Associativity<sup>2</sup>: \\(A(BC) = (AB)C\\)</li> <li> Distributivity: \\(A(B + C) = AB + AC\\) and \\((B + C)A = BA + CA\\)</li> <li> No commutativity: \\(AB = BA\\) isn't always true</li> </ul> <p>The geometric product of anything involving a scalar is just scalar multiplication, which does commute: \\(x3 = 3x\\). But what if we multiply two vector components? If the vectors are the same, like \\(xx\\), then they cancel and the result is \\(1\\). If the vectors are different, like \\(xy\\), then we get something new: a bivector.</p> <p>There are three unique bivectors in VGA: \\(xy\\), \\(xz\\), and \\(yz\\). You can swap the letters of a bivector if you swap the sign, like \\(xy = -yx\\), so we don't need a separate \\(yx\\) component.</p> <p>Let's make a multiplication table! Check for yourself that each entry in here makes sense. (left times top)</p> \\(1\\) \\(x\\) \\(y\\) \\(z\\) \\(x\\) \\(1\\) \\(xy\\) \\(xz\\) \\(y\\) \\(-xy\\) \\(1\\) \\(yz\\) \\(z\\) \\(-xz\\) \\(-yz\\) \\(1\\) <p>What happens when you multiply a bivector by a vector? Well when we multiply \\(xy\\) by \\(x\\), we get \\(xyx\\). We can simplify \\(yx\\) to \\(-xy\\), and then \\(xx\\) simplifies to \\(1\\), so:</p> \\[ \\begin{align} xyx &amp;= x(-xy) \\\\ &amp;= -xxy \\\\ &amp;= -y \\end{align} \\] <p>But if we have three different letters, then it doesn't simplify: multiplying \\(xy\\) by \\(z\\) results in the trivector \\(xyz\\), our eighth and final basis vector. In general, a geometric algebra with \\(n\\) vector components will have \\(2^n\\) basis vectors.</p> <p>Let's make an even bigger multiplication table!</p> \\(1\\) \\(x\\) \\(y\\) \\(z\\) \\(xy\\) \\(xz\\) \\(yz\\) \\(xyz\\) \\(x\\) \\(1\\) \\(xy\\) \\(xz\\) \\(y\\) \\(z\\) \\(xyz\\) \\(yz\\) \\(y\\) \\(-xy\\) \\(1\\) \\(yz\\) \\(-x\\) \\(-xyz\\) \\(z\\) \\(-xz\\) \\(z\\) \\(-xz\\) \\(-yz\\) \\(1\\) \\(xyz\\) \\(-x\\) \\(-y\\) \\(xy\\) \\(xy\\) \\(-y\\) \\(x\\) \\(xyz\\) \\(-1\\) \\(-yz\\) \\(xz\\) \\(-z\\) \\(xz\\) \\(-z\\) \\(-xyz\\) \\(x\\) \\(yz\\) \\(-1\\) \\(-xy\\) \\(y\\) \\(yz\\) \\(xyz\\) \\(-z\\) \\(y\\) \\(-xz\\) \\(xy\\) \\(-1\\) \\(-x\\) \\(xyz\\) \\(yz\\) \\(-xz\\) \\(xy\\) \\(-z\\) \\(y\\) \\(-x\\) \\(-1\\) <p>But what do all these components actually represent? Well just like the vector \\(x\\) represents one unit of distance in the positive direction along the X axis, the bivector \\(xy\\) represents one unit of positively-oriented area in the XY plane. And a trivector \\(xyz\\) represents one unit of positively-oriented volume in 3D space. Orientation is just a thing that changes when you flip the sign, so \\(xy\\) has positive orientation and \\(-xy\\) has negative orientation. Don't worry if that doesn't make much sense.</p> <p>A bivector with multiple components represents non-axis-aligned area. Consider the vector \\(x+2y\\), which represents some length in the XY plane. Its projection onto the X axis is one unit long, and its projection onto the Y axis is two units long. Similarly, \\(2xy+xz-3yz\\) represents an oriented area in the XYZ 3D space. Its projection (2D shadow) onto the XY plane has two units of positively-oriented area, its projection onto the XZ plane has 1 unit of positively-oriented area, and its projection onto the YZ plane has 3 units of negatively-oriented area. This is hard to visualize if you haven't seen it before; check out Marc ten Bosch's explanation of rotors if you're confused.</p>"},{"location":"hsc/internals/vga/#blades-and-grades","title":"Blades and grades","text":"<p>It's time for some new terminology:</p> <ul> <li>The grade of a multivector is the number of letters each component has. A scalar has grade 0, a vector has grade 1, a bivector has grade 2, a trivector has grade 3, etc.</li> <li>A blade is a multivector whose components all have the same grade.</li> <li>An \\(r\\)-blade is a blade with grade \\(r\\) (where \\(r\\) is a nonnegative integer).</li> <li>The pseudoscalar \\(I\\) (or <code>pss</code> in code) is the unit-length multivector with maximum grade. In 3D space, \\(I = xyz\\).</li> </ul> <p>To get a blade from a multivector, you can grade-project it, which extracts all the components of a particular grade. The projection of \\(A\\) into grade \\(r\\) is written \\(\\langle A \\rangle_r\\).</p> <p>Most of the time, all the multivectors we see will be blades. The only exception to this rule is rotors, which we'll get to later.</p> <p>Conventions</p> <ul> <li>\\(C_r\\) is an arbitrary blade with grade \\(r\\)</li> <li>\\(D_s\\) is an arbitrary blade with grade \\(s\\)</li> </ul>"},{"location":"hsc/internals/vga/#outer-product-wedge-product","title":"Outer product (wedge product)","text":"<p>The wedge product or outer product of \\(C_r\\) and \\(D_s\\) is written \\(C_r \\wedge D_s\\) (\"\\(C_r\\) wedge \\(D_s\\)\") and is defined as \\(\\langle C_r D_s \\rangle_{r+s}\\). In code, the wedge product of <code>a</code> and <code>b</code> is written <code>a ^ b</code>.</p> Wedge product of general multivectors <p>We only ever need to compute the wedge product of two blades, but the wedge product of general multivectors exists too. \\(A \\wedge B\\) can be computed by breaking down \\(A\\) and \\(B\\) into their individual terms, computing the wedge product of each pair of terms separately, and then summing the result.</p> <p>To give an intuitive understanding: When computing the geometric product of two multivectors, you get a lot of different components of different grades. The outer product selects only the components with the maximum possible grade. Here's some examples of how that works:</p> <ul> <li>The outer product of two vectors is always a bivector, with no scalar component (or zero, if the vectors are parallel).</li> <li>The outer product of a bivector and a vector is always a trivector (or zero, if the vector is in the same plane as the bivector).</li> <li>The outer product of a trivector and a vector is always a quadvector or zero. In 3D VGA, we have no quadvectors, so it is always zero.</li> <li>The outer product with a scalar is the same as ordinary multiplication by that scalar.</li> </ul> <p>Outer product visualization</p> <p> CC0 from Wikipedia</p> <p>Click for full size</p> <p>The outer product has a really nice geometric interpretation. The outer product of two vectors \\(a \\wedge b\\) is a bivector representing the oriented area swept out by moving \\(b\\) along \\(a\\). Adding a third vector gives \\(a \\wedge b \\wedge c\\), a trivector that represents the oriented volume generated by sweeping \\(c\\) over the whole surface of \\(a \\wedge b\\).</p> <p>This area and volume are oriented because they face in a particular direction. In the image to the right, this is represented by the circular orange arrows. If you swap any two adjacent vectors in the outer product, then the sign of the result flips. In general, \\(a \\wedge b = -b \\wedge a\\). This property is called anticommutativity, and it will be a common theme as we learn more about geometric algebra. Note the outer product is anticommutative for vectors, but not generally for multivectors. Later we'll learn about how to compute these operations and how to know when the sign changes.</p> <p>This looks suspiciously similar to the determinant of a matrix ...</p> <p>This is no coincidence! The determinant of a matrix is exactly equal to the pseudoscalar component of the outer product of its column vectors. Think about properties of the determinant, like how behaves when you swap adjacent columns or its representation of signed area/volume.</p>"},{"location":"hsc/internals/vga/#inner-product","title":"Inner product","text":"<p>There's a few different ways to generalize inner products to work on multivectors.</p>"},{"location":"hsc/internals/vga/#scalar-dot-product","title":"Scalar dot product","text":"<p>The scalar dot product (or simply dot product) of two multivectors \\(A\\) and \\(B\\) is written \\(A \\cdot B\\) (\"\\(A\\) dot \\(B\\)\") and is defined as \\(\\langle AB \\rangle_{0}\\), i.e., the scalar component of the geometric product. This is one of several inner products. The scalar dot product is commutative for vectors (so \\(a \\cdot b = b \\cdot a\\)) but not generally for multivectors.</p> <p>Exercise</p> <p>Think about why the dot product of two blades with different grades is always zero.</p> <p>Common misconception: \\(AB = A \\wedge B + A \\cdot B\\)</p> <p>There's a misconception in geometric algebra that the geometric product is the sum of the outer and inner products. This is true when multiplying vectors (so \\(ab = a \\wedge b + a \\cdot b\\) is true) but not generally for multivectors (so \\(AB = A \\wedge B + A \\cdot B\\) does not always hold).</p> <p>Using the dot product, we can also define the magnitude of a multivector \\(\\|A\\| = \\sqrt{A \\cdot A}\\). Note that the magnitude of a multivector is not always real; for example, the \\(xy \\cdot xy = -1\\), so its magnitude would be \\(\\sqrt{-1}\\), which is imaginary.</p>"},{"location":"hsc/internals/vga/#contraction","title":"Contraction","text":"<p>The left contraction of \\(C_r\\) and \\(D_s\\) is written \\(C_r \\rfloor D_s\\) (\"\\(C_r\\) left-contract \\(D_s\\)\" or \"\\(C_r\\) contracted from \\(D_s\\)) and is defined as \\(\\langle C_r D_s \\rangle_{s-r}\\). In code, the left contraction of <code>a</code> and <code>b</code> is written <code>a &lt;&lt; b</code>.</p> <p>Exercise</p> <ol> <li>When is left contraction equivalent to the scalar dot product?</li> <li> Bonus  When is left contraction equivalent to the geometric product? (The answer is revealed later, in case you're stuck.)</li> </ol> <p>I have to admit that I don't have a great geometric understanding of left contraction. My understanding is that it's sort of a way to \"remove\" some multivector from a product of vectors, but that intuition may be wrong.</p> <p>For completeness: the right contraction of \\(C_r\\) and \\(D_s\\) is written \\(C_r \\lfloor D_s\\) and is defined as \\(\\langle C_r D_s \\rangle_{r-s}\\), but we'll never use it.</p>"},{"location":"hsc/internals/vga/#reverse","title":"Reverse","text":"<p>The reverse of a multivector \\(A\\) is written \\(A^\\dagger\\). It's computed by reversing the order of all the basis vectors in each component. For example, the reverse of \\(2x + 3xz + 4xyz\\) is \\(2x + 3zx + 4zyx\\). Using the rule that \\(xy = -yx\\), we can simplify this to \\(2x - 3xz - 4xyz\\).</p> <p>In general, a multivector can be reversed by negating each of its components with grade \\(1\\) or \\(2\\) mod 4. Components with grade \\(0\\) or \\(3\\) mod 4 remain unchanged.</p>"},{"location":"hsc/internals/vga/#inverse","title":"Inverse","text":"<p>The multiplicative inverse of a multivector is written \\(A^{-1}\\). It's computed using the formula \\(A^{-1} = \\frac{A^\\dagger}{A A^\\dagger}\\), which I stole from Mathematics Stack Exchange. This means we can technically do division with multivectors? Wacky!</p> <p>Not all multivectors have a multiplicative inverse, especially once we get to projective and conformal geometric algebra.</p> <p>Exercise</p> <p>A particularly important inverse is that of the pseudoscalar \\(I\\).</p> <ol> <li>Write the pseudoscalar and its inverse for dimensions 1 to 8.</li> <li>Identify a pattern in the relationship between the pseudoscalar and its inverse depending on the number of dimensions.</li> </ol>"},{"location":"hsc/internals/vga/#dual","title":"Dual","text":"<p>The dual of a multivector \\(A\\) is written \\(\\tilde A\\) (\"\\(A\\) tilde\"). In code, the dual of <code>a</code> is written <code>!a</code>, <code>a &lt;&lt; pss</code> where <code>pss</code> is the pseudoscalar.</p> <p>This hints at how to compute the dual of a multivector: just multiply it by the pseudoscalar. We'll usually avoid the notation \\(\\tilde A\\) in favor of explicitly multiplying by the pseudoscalar, since sometimes we'll have to multiply by the inverse of the pseudoscalar, which flips the sign in certain dimensions.</p> <p>Exercise</p> <p>Think about why <code>a &lt;&lt; pss</code> and <code>a * pss</code> are always equivalent, even though in general <code>a &lt;&lt; b</code> isn't equivalent to <code>a * b</code>.</p>"},{"location":"hsc/internals/vga/#rotors","title":"Rotors","text":"<p>Now that you understand multivectors and the geometric, outer, and inner products, read and/or watch Marc ten Bosch's explanation of rotors. It also contains excellent interactive demos of bivectors.</p> <p>Important things to note:</p> <ul> <li>In general, rotors use the even subalgebra of geometric algebra; i.e., they are multivectors where each component has even grade. That means they have scalar, bivector, quadvector, etc. components.</li> <li>The rotor \\(ab\\) represents a rotation in the plane spanned by \\(a\\) and \\(b\\) by twice the angle between \\(a\\) and \\(b\\).</li> <li>The reverse of a rotor represents the reverse transformation.</li> <li>The geometric product of two rotors is their composition.</li> <li>To apply a rotor \\(R\\) to an object \\(A\\), compute the sandwich product \\(R A R^\\dagger\\).</li> </ul> <p>Rotors can be generalized to rotoreflectors, which use the odd subalgebra of geometric algebra. These work exactly like rotors except that they represent an odd number of reflections and you have to negate the result when applying them: \\(-R A R^\\dagger\\). (There's a negation for each reflection, but ordinary rotors have two reflections so the negations cancels.)</p> <ol> <li> <p>In fact, complex numbers are a geometric algebra! You can think of them either as a 1D GA with a single extra basis vector \\(i^2=-1\\), or as the even subalgebra of 2D VGA \u2014 but I'm getting ahead of myself.\u00a0\u21a9</p> </li> <li> <p>If you ever see a non-associative algebra (like the octonions), run far, far away and never look back. They are utter hell.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/lua/basics/","title":"Basics","text":"<p>See the Lua 5.4 reference manual for general Lua functionality.</p> <p>Hyperspeedcube user code is run in a sandbox, with some Lua functionality restricted. The following globals are available from the Lua standard library:</p> <ul> <li>Constants: <code>_VERSION</code></li> <li>Functions: <code>ipairs</code>, <code>next</code>, <code>pairs</code>, <code>pcall</code>, <code>select</code>, <code>tonumber</code>, <code>tostring</code>, <code>unpack</code></li> <li>Modules: <code>math</code>, <code>string</code>, <code>table</code>, <code>utf8</code></li> </ul> <p>The <code>math</code> module has been slightly modified; see the Math section for more.</p> <p>The following functions have been slightly modified from their default behavior to capture their output or account for new types, but should otherwise behave approximately the same as they do in the Lua standard library:</p> <ul> <li>Modified functions: <code>assert</code>, <code>error</code>, <code>print</code>, <code>type</code>, <code>warn</code></li> </ul> <p>The function <code>setmetatable()</code> is accessible, however it has been modified to return a shallow copy of its input table instead of modifying an existing table. <code>getmetatable()</code> is not accessible, for safety reasons.</p>"},{"location":"hsc/lua/basics/#operators","title":"Operators","text":"<p>The following unary (one-input) prefix operators are unmodified from standard Lua:</p> <ul> <li><code>-</code> (negation)</li> <li><code>~</code> (bitwise NOT)</li> </ul> <p>The following binary (two-input) operators are unmodified from standard Lua:</p> <ul> <li><code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> (addition, subtraction, multiplication, and division)</li> <li><code>//</code> (floor division)</li> <li><code>%</code> (modulo)</li> <li><code>^</code> (exponentiation)</li> <li><code>&lt;&lt;</code> and <code>&gt;&gt;</code> (bitshift operators)</li> <li><code>&amp;</code>, <code>|</code>, and <code>~</code> (bitwise and/or/xor)</li> <li><code>..</code> (string concatenation)</li> <li><code>&lt;</code> and <code>&gt;</code> (less/greater than)</li> <li><code>&lt;=</code> and <code>&gt;=</code> (less/greater than or equal to)</li> <li><code>==</code> (equality)</li> <li><code>~=</code> (inequality)</li> <li><code>and</code>, <code>or</code>, and <code>not</code> (logical operators)</li> </ul> <p>See the Approximate equality section for alternatives to <code>==</code> and <code>~=</code> that check for approximate equality.</p>"},{"location":"hsc/lua/basics/#global-constants","title":"Global constants","text":"<p>The following global constants have been added:</p> <ul> <li><code>_PUZZLE_ENGINE</code> is a string containing the program name and version; e.g., <code>\"hyperspeedcube v2.0.0\"</code></li> <li><code>AXES</code> is a table mapping axis names to numbers and vice versa</li> <li><code>SPACE</code> is currently active space</li> <li><code>NDIM</code> is the number of dimensions of the currently active space</li> <li><code>lib</code> provides access to other Lua files; see below</li> <li><code>color_systems</code> is the global color systems library</li> <li><code>puzzle_generators</code> is the global puzzle generators library</li> <li><code>puzzles</code> is the global puzzle library</li> </ul>"},{"location":"hsc/lua/basics/#lib","title":"<code>lib</code>","text":"<p><code>lib</code> is a table that provides access to global variables and functions defined in other Lua files. For example, <code>lib.utils</code> returns a table of global variables and functions defined in <code>utils.lua</code>, and <code>lib.symmetries.cubic</code> returns a similar table for <code>symmetries/cubic.lua</code>.</p> Example using <code>lib</code> utils/my_utility_file.lua<pre><code>function hello()\n  return \"Hello, world!\"\nend\n\nfavorite_number = 12\n\nlocal super_secret = \"can't touch this\"\n</code></pre> demos/some_other_file.lua<pre><code>local my_utils = lib.utils.my_utility_file\nprint(my_utils.hello()) -- Hello, world!\nprint(my_utils.favorite_number) -- 12\nprint(my_utils.super_secret) -- nil\n</code></pre> Example using <code>lib</code> with subdirectories friends/luna.lua<pre><code>name = \"Luna Harran\"\n</code></pre> friends/milo.lua<pre><code>name = \"Milo Jacquet\"\n</code></pre> friends/rowan.lua<pre><code>name = \"Rowan Fortier\"\n</code></pre> demos/friends_demo.lua<pre><code>print(lib.friends.luna.name) -- Luna Harran\nprint(lib.friends.milo.name) -- Milo Jacquet\nprint(lib.friends.rowan.name) -- Rowan Fortier\n</code></pre> <p>Note that <code>pairs()</code> does not work with <code>lib</code> and other tables, since the files are loaded dynamically as needed.</p> <p>Circular dependencies between files are not allowed and will result in errors.</p>"},{"location":"hsc/lua/basics/#global-functions","title":"Global functions","text":"<p>The following global functions have been added:</p>"},{"location":"hsc/lua/basics/#pstringv","title":"<code>pstring(v)</code>","text":"<p>Converts a value <code>v</code> of any type to a string in a \"pretty\" way:</p> <ul> <li>Strings are escaped</li> <li>Tables have their contents printed (safe with recursive tables)</li> <li>All other types use <code>tostring()</code></li> </ul>"},{"location":"hsc/lua/basics/#pprint","title":"<code>pprint(...)</code>","text":"<p>Same as <code>print()</code> function built into Lua, but uses <code>pstring()</code> instead of <code>tostring()</code>.</p>"},{"location":"hsc/lua/basics/#math","title":"Math","text":"<p>The Lua math API is almost unmodified from Lua.</p> <ul> <li>The functions <code>math.random</code> and <code>math.randomseed</code> have been removed because puzzle definitions (with the exception of certain novelty puzzles) should be deterministic.</li> <li>The functions <code>math.deg</code> and <code>math.rad</code> have been removed because they have confusing names and semantics. They have been replaced by <code>math.degree</code>, a constant equal to the number of radians in one degree.</li> <li>Some new functions and constants have been added; they are described below.</li> </ul> <p>Since mathematical functions are used very often in puzzle development, most of the contents of the math module have been placed in the global scope. For example, <code>sqrt(3)</code> is equivalent to <code>math.sqrt(3)</code>.</p> <p>The following functions and constants are available from the math module.</p>"},{"location":"hsc/lua/basics/#trigonometry","title":"Trigonometry","text":"<ul> <li><code>math.sin()</code>, <code>math.cos()</code>, <code>math.tan()</code></li> <li><code>math.asin()</code>, <code>math.acos()</code>, <code>math.atan()</code></li> <li><code>math.pi</code></li> </ul> <p>The following additional trigonometric constants have been added:</p> <ul> <li><code>math.tau</code> is equivalent to <code>math.pi * 2</code></li> <li><code>math.degree</code> is equivalent to <code>math.pi / 180</code></li> <li><code>math.phi</code> is equivalent to <code>(1 + math.sqrt(5)) / 2</code></li> </ul> <p>All trigonometric functions and constants are accessible as globals. For example <code>pi</code> and <code>math.pi</code> are equivalent.</p>"},{"location":"hsc/lua/basics/#mathematical-functions","title":"Mathematical functions","text":"<ul> <li><code>math.ceil()</code>, <code>math.floor()</code></li> <li><code>math.max()</code>, <code>math.min()</code></li> <li><code>math.abs()</code></li> <li><code>math.exp()</code></li> <li><code>math.fmod()</code></li> <li><code>math.log()</code></li> <li><code>math.modf()</code></li> <li><code>math.sqrt()</code></li> </ul> <p>The following additional mathematical functions have been added:</p> <ul> <li><code>math.round(x)</code> rounds a number to the nearest integer<sup>1</sup></li> </ul> <p>All these functions are accessible as globals. For example <code>sqrt(3)</code> and <code>math.sqrt(3)</code> are equivalent.</p>"},{"location":"hsc/lua/basics/#implementation-utilities","title":"Implementation utilities","text":"<ul> <li><code>math.maxinteger</code> and <code>math.mininteger</code></li> <li><code>math.huge</code></li> <li><code>math.ult</code></li> <li><code>math.tointeger</code></li> <li><code>math.type</code></li> </ul> <p>These functions and constants are not accessible as globals.</p>"},{"location":"hsc/lua/basics/#approximate-equality","title":"Approximate equality","text":"<p>Calculations done with floating-point numbers are often inexact, so it can often happen that numbers you expect to be equivalent might not be. The best way to remedy this is to never compare floating-point numbers at all, and for most puzzle definitions, you probably won't need to. But for the rare cases where you do, the following functions are provided that check for approximate equality:</p> <ul> <li><code>math.eq(a, b)</code> returns whether <code>abs(a - b) &lt;= EPSILON</code></li> <li><code>math.neq(a, b)</code> returns whether <code>abs(a - b) &gt; EPSILON</code></li> </ul> <p><code>EPSILON</code> is a built-in constant containing a very small number. At the time of writing it is <code>0.000001</code>, but this is subject to change in the future.</p> <p>Experiment</p> <p>Currently, <code>math.eq</code> and <code>math.neq</code> only accept numbers. In the future, they may accept other types such as <code>blade</code>s and <code>transform</code>s.</p> <p><code>math.eq()</code> and <code>math.neq()</code> are not accessible as globals.</p>"},{"location":"hsc/lua/basics/#strings","title":"Strings","text":"<p>The entire Lua string API is unmodified.</p> <p>The following additional string functions have been added:</p> <ul> <li><code>string.fmt2(s1, s2, ...)</code> is equivalent a <code>string.format(s1, ...), string.format(s2, ...)</code></li> </ul>"},{"location":"hsc/lua/basics/#utf-8","title":"UTF-8","text":"<p>The entire Lua UTF-8 API is unmodified.</p>"},{"location":"hsc/lua/basics/#tables","title":"Tables","text":"<p>The entire Lua table API is unmodified.</p> <ol> <li> <p>If <code>x</code> is half-way between two integers, <code>math.round(x)</code> rounds away from <code>0.0</code>. Internally, it uses Rust's rounding semantics.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/lua/color-system-library/","title":"Color system library","text":"<p>The color system library is the database of all known color systems that are shared by multiple puzzles. The global variable <code>color_systems</code> contains the global color system library.</p> <p>A color scheme is a mapping from puzzle color (<code>R</code>, <code>U</code>, etc.) to default color (<code>Red</code>, <code>White</code>, etc.). A color system is a set of color names and at least one color scheme.</p>"},{"location":"hsc/lua/color-system-library/#methods","title":"Methods","text":""},{"location":"hsc/lua/color-system-library/#color_systemsadd","title":"<code>color_systems:add()</code>","text":"<p><code>color_systems:add()</code> adds a color system to the global color system library. It takes two arguments: the unique string ID for the color system (which may be the same as a puzzle ID), and a table containing the color system data with the following keys:</p> <ul> <li><code>id</code> is a string containing a unique ID for the color system</li> <li><code>name</code> is a string containing a user-facing name for the color system</li> <li><code>colors</code> is a sequential table of color names and display names in order</li> <li><code>schemes</code> is a sequential table of color scheme definitions</li> <li><code>default</code> is either a color scheme definition or a string the name of a color scheme defined in <code>schemes</code></li> </ul> <p>The key <code>colors</code> is required. All other keys are optional.</p> <p>To use a color system in a puzzle, set the puzzle's <code>colors</code> key to the string ID of the color system. The colors of the puzzle must exactly match its color system.</p>"},{"location":"hsc/lua/color-system-library/#colors","title":"<code>colors</code>","text":"<p><code>colors</code> is a sequential table, where each element is a table with the following keys:</p> <ul> <li><code>name</code> is a string containing a name for the color (e.g., <code>R</code>)</li> <li><code>display</code> is a string containing a user-facing display name for the color (e.g., <code>Right</code>)</li> <li><code>default</code> is a string containing a default color.</li> </ul> <p>The key <code>name</code> is required. All other keys are optional. <code>default</code> is only allowed when <code>schemes</code> and <code>default</code> are <code>nil</code>.</p>"},{"location":"hsc/lua/color-system-library/#color-scheme-definitions","title":"Color scheme definitions","text":"<p>A color scheme definition is a table mapping puzzle colors to default colors. Each key is a string containing a color name, and the corresponding value is a string representing a default color. Each puzzle color must be assigned a unique default color.</p>"},{"location":"hsc/lua/color-system-library/#default-colors","title":"Default colors","text":"<p>A default color is a string corresponding to a color from the global color palette. To get the name of a default color, mouse over it in the color scheme panel in Hyperspeedcube.</p> <p>Colors from color sets end with a number in square brackets. For example, <code>Red Traid [3]</code> is the third color from the \"Red Triad\" set.</p> <p>Colors from gradients end with two numbers in square brackets separated by a slash, where the first number is the index within the gradient and the second number is the total number of colors assigned to the gradient. For  <code>Rainbow [3/5]</code> is the third color in the rainbow when five colors have been assigned to it.</p>"},{"location":"hsc/lua/color-system-library/#operations","title":"Operations","text":"<ul> <li><code>#puzzles</code> returns the number of puzzles that have been loaded</li> <li><code>type(puzzles)</code> returns <code>'puzzledb'</code></li> </ul>"},{"location":"hsc/lua/color-system-library/#examples","title":"Examples","text":"Standard Rubik's cube color system<pre><code>color_systems:add('cube', {\n  name = \"Cube\",\n\n  colors = {\n    { name = 'R', display = \"Right\" },\n    { name = 'L', display = \"Left\" },\n    { name = 'U', display = \"Up\" },\n    { name = 'D', display = \"Down\" },\n    { name = 'F', display = \"Front\" },\n    { name = 'B', display = \"Back\" },\n  },\n\n  schemes = {\n    {\"Western\", {\n      R = \"Red\",\n      L = \"Orange\",\n      U = \"White\",\n      D = \"Yellow\",\n      F = \"Green\",\n      B = \"Blue\",\n    }},\n    {\"Japanese\", {\n      R = \"Red\",\n      L = \"Orange\",\n      U = \"White\",\n      D = \"Blue\",\n      F = \"Green\",\n      B = \"Yellow\",\n    }},\n  },\n\n  default = \"Western\",\n})\n</code></pre> Standard Rubik's hypercube color system<pre><code>color_systems:add('hypercube', {\n  name = \"Hypercube\",\n\n  colors = {\n    { name = 'R', display = \"Right\", default = \"Red\" },\n    { name = 'L', display = \"Left\",  default = \"Orange\" },\n    { name = 'U', display = \"Up\",    default = \"White\" },\n    { name = 'D', display = \"Down\",  default = \"Yellow\" },\n    { name = 'F', display = \"Front\", default = \"Green\" },\n    { name = 'B', display = \"Back\",  default = \"Blue\" },\n    { name = 'O', display = \"Out\",   default = \"Pink\" },\n    { name = 'I', display = \"In\",    default = \"Purple\" },\n  },\n})\n</code></pre>"},{"location":"hsc/lua/common/","title":"Common patterns","text":"<p>Several types have methods that behave similarly and are implemented using the same generic code. To keep the documentation consistent and concise, they are all documented here.</p> <p>On this page:</p> <ul> <li>An element is a color, axis, or twist, or the index or name of one</li> <li>A value is some other value (often a string or number, but not always)</li> </ul>"},{"location":"hsc/lua/common/#mappings","title":"Mappings","text":"<p>A mapping associates a value to each element. A mapping may be either of the following:</p> <ul> <li>a function from elements to values</li> <li>a table whose keys are elements and whose values are the resulting values</li> </ul> <p>See <code>:rename()</code> for an example of each of these.</p>"},{"location":"hsc/lua/common/#common-methods","title":"Common methods","text":""},{"location":"hsc/lua/common/#rename","title":"<code>:rename()</code>","text":"<p><code>:rename()</code> renames multiple elements at once. It takes a single argument: a mapping from elements to strings (the new names).</p> Examples of puzzle.colors:rename()<pre><code>-- Assign existing colors new names, in their current ordering\npuzzle.colors:rename{'Right', 'Left', 'Up', 'Down'}\n\n-- Rename colors based on their old names\npuzzle.colors:rename(function(color)\n  return \"Old \" .. color.name\nend)\n</code></pre>"},{"location":"hsc/lua/common/#swap","title":"<code>:swap()</code>","text":"<p><code>:swap()</code> swaps two elements in the ordering. It takes two arguments: the elements to swap.</p>"},{"location":"hsc/lua/common/#reorder","title":"<code>:reorder()</code>","text":"<p><code>:reorder()</code> changes the ordering of all elements. It takes a single argument: a sequential table of elements in the new order, or a function mapping elements to new indices.</p> <p>The keys of the table or the outputs of the function do not actually need to be sequential integers; they may be any numbers, and will be sorted by their values.</p> <p>The sort is stable, and any unspecified elements are left at the end of the list in their original order.</p>"},{"location":"hsc/lua/puzzle-library/","title":"Puzzle library","text":"<p>The puzzle library is the database of all known puzzle definitions. The global variable <code>puzzles</code> contains the global puzzle library.</p>"},{"location":"hsc/lua/puzzle-library/#methods","title":"Methods","text":""},{"location":"hsc/lua/puzzle-library/#puzzlesadd","title":"<code>puzzles:add()</code>","text":"<p><code>puzzles:add()</code> adds a puzzle to the global puzzle library. It takes one argument: a table containing the following keys:</p> <ul> <li><code>id</code> is a string containing a unique ID for the puzzle</li> <li><code>version</code> is a string containing the semantic version for the puzzle</li> <li><code>name</code> is a string containing a user-facing name for the puzzle</li> <li><code>tags</code> is a table containing a tag specification.</li> <li><code>colors</code> is a string containing the ID of a color system in the color system library</li> <li><code>ndim</code> is the number of dimensions for the puzzle</li> <li><code>build</code> is a function used to construct the puzzle</li> </ul> <p>The keys <code>id</code>, <code>version</code>, <code>ndim</code> and <code>build</code> are required. All other keys are optional. The keys <code>name</code>, <code>tags</code>, and <code>colors</code> are recommended.</p> <p>The puzzle is not constructed immediately when <code>puzzles:add()</code> is called. (Otherwise, the program would slow to a crawl loading all the puzzles on startup.) Instead, only the ID, name, tags, and other metadata is stored.</p> <p>When the user first opens a puzzle, a puzzle object is initialized with a new <code>ndim</code>-dimensional space, and an empty color system, axis system, and twist system; <code>build</code> is then called with that puzzle as its argument. <code>build</code> is responsible for cutting the pieces and defining colors, axes, and twists. See Puzzle, Colors, Axes, and Twists for more.</p>"},{"location":"hsc/lua/puzzle-library/#operations","title":"Operations","text":"<ul> <li><code>#puzzles</code> returns the number of puzzles that have been loaded</li> <li><code>type(puzzles)</code> returns <code>'puzzledb'</code></li> </ul>"},{"location":"hsc/lua/tags/","title":"Tags","text":"<p>Hyperspeedcube uses a tag-based system to organize puzzles (as opposed to the hierarchical organization used by many other puzzle programs). Tags are organized in a hierarchy, where one tag may have several subtags. For example, <code>shape/3d/platonic/cube</code> is a subtag of <code>shape/3d/platonic</code>, which is a subtag of <code>shape/3d</code>, which is a subtag of <code>shape</code>. For each tagged object (including puzzles and puzzle generators), a tag may have an associated value of one of the following types:</p> <ul> <li>Boolean (<code>true</code> or <code>false</code>)</li> <li>Integer</li> <li>String</li> <li>String list</li> <li>Puzzle name</li> </ul> <p>Most tags have the boolean value, so the tables on this page only indicate a tag's type if it is not boolean. A tag is present if it is assigned any value other than <code>false</code>, or if any of its subtags are present. The value <code>false</code> is valid for all tags, regardless of type.</p> <p>Some tags (such as <code>colors/system</code>) are automatically added when generating the puzzle and so do not need to be specified in the puzzle definition. Most tags are not automatically added, so the tables on this page only indicate if they are.</p>"},{"location":"hsc/lua/tags/#list-of-tags","title":"List of tags","text":"<p><code>hyperpuzzle/src/tags.kdl</code> is the most up-to-date list of tags. If you're doing puzzle development, it's a good idea to skim that list. Note that leading underscores are removed, so <code>_120cell</code> becomes <code>120cell</code>.</p>"},{"location":"hsc/lua/tags/#type","title":"Type","text":"<p>The <code>type</code> tag indicates whether an object is a shape, puzzle, or generator.</p> Tag Description <code>type/shape</code> Shape only (cannot be scrambled) <code>type/puzzle</code> Puzzle (can be scrambled) <code>type/generator</code> (auto) Puzzle/shape generator <p><code>type/shape</code> should be included on generators that only generate shapes. <code>type/puzzle</code> is not necessary on puzzles that only generate puzzles.</p>"},{"location":"hsc/lua/tags/#shapes","title":"Shapes","text":"<p>The <code>shape</code> tags indicate the physical shape of the puzzle. A puzzle will typically only have one <code>shape</code> tag (plus its parent tags). If a puzzle has a unique shape that is not listed here, it should have a dimension tag (such as <code>shape/3d</code>).</p> <p>Shape tags are always boolean (<code>true</code> or <code>false</code>).</p> <p>Here are a few of the most common shape tags:</p> Tag Description <code>shape/3d/platonic/cube</code> Cube <code>shape/3d/platonic/tetrahedron</code> Tetrahedron <code>shape/3d/platonic/dodecahedron</code> Dodecahedron <code>shape/3d/platonic/octahedron</code> Octahedron <code>shape/3d/platonic/icosahedron</code> Icosahedron <code>shape/3d/prism</code> Polygonal prism <code>shape/3d/compound</code> Polyhedral compound <code>shape/4d/platonic/hypercube</code> Hypercube (4D) <code>shape/4d/platonic/simplex</code> 4-simplex <code>shape/4d/platonic/120cell</code> 120-cell <code>shape/4d/platonic/prism/dodecahedron</code> Dodecahedral prism <code>shape/4d/platonic/duoprism</code> Polygon-polygon duoprism <code>shape/5d/platonic/simplex</code> 5-simplex <code>shape/5d/platonic/hypercube</code> Hypercube (5D) <p>There are many more shape tags (including Archimedian and Catalan solids) defined in <code>tags.kdl</code>. More will be added as they are used in puzzles.</p>"},{"location":"hsc/lua/tags/#colors","title":"Colors","text":"<p>The <code>colors</code> tags relate to the color system of the puzzle.</p> Tag Type Description <code>colors/system</code> (auto) string Color system name <code>colors/multi_per_facet</code> Present if there is a facet with multiple colors <code>colors/multi_facet_per</code> Preset if multiple facets have the same color"},{"location":"hsc/lua/tags/#shapeshifting","title":"Shapeshifting","text":"<p>Shapeshifting is a unique emergent property from the shape and the axis system.</p> Tag Description <code>shapeshifting</code> Present if any puzzle states have different shapes"},{"location":"hsc/lua/tags/#axes","title":"Axes","text":"<p>The <code>axes</code> tags indicate the axis system(s) of the puzzle. A puzzle may have multiple independent axis systems, although most will only have one. If a puzzle has a unique axis system that is not listed here, it should have a dimension tag (such as <code>axes/3d</code>).</p> <p>Here are a few of the most common axis system tags:</p> Tag Description <code>axes/3d/elementary/cubic</code> Cubic axes <code>axes/3d/elementary/tetrahedral</code> Tetrahedral axes <code>axes/3d/elementary/dodecahedral</code> Dodecahedral axes <code>axes/3d/elementary/octahedral</code> Octahedral axes <code>axes/3d/elementary/icosahedral</code> Icosahedral axes <code>axes/3d/prism</code> Polygonal prism axes <code>axes/3d/compound</code> Polyhedral compound axes <code>axes/4d/elementary/hypercube</code> Hypercubic axes (4D) <code>axes/4d/elementary/simplex</code> 4-simplex axes <code>axes/4d/elementary/120cell</code> 120-cell axes <code>axes/4d/elementary/prism/dodecahedron</code> Dodecahedral prism axes <code>axes/4d/elementary/duoprism</code> Polygon-polygon duoprism axes <code>axes/5d/elementary/simplex</code> 5-simplex axes <code>axes/5d/elementary/hypercube</code> Hypercubic axes (5D)"},{"location":"hsc/lua/tags/#turning-element","title":"Turning element","text":"<p>The <code>turns_by</code> tags indicate which element(s) of the shape correspond to the twisting axes. Since these can be synonyms in low dimensions (for instance, in 3 dimensions, face and facet are the same), most puzzles will have more than one of these tags.</p> Tag Description <code>turns_by/facet</code> Facet-turning <code>turns_by/ridge</code> Ridge-turning <code>turns_by/peak</code> Peak-turning <code>turns_by/cell</code> Cell-turning <code>turns_by/face</code> Face-turning <code>turns_by/edge</code> Edge-turning <code>turns_by/vertex</code> Vertex-turning <code>turns_by/other</code> Turns by some other element of the polytope"},{"location":"hsc/lua/tags/#completeness","title":"Completeness","text":"Tag Description <code>completeness/super</code> Each piece has only one solved attitude <code>completeness/real</code> All non-core internal pieces are present and each can be unsolved <code>completeness/complex</code> The puzzle is complex <code>completeness/laminated</code> The puzzle is laminated"},{"location":"hsc/lua/tags/#algebraic-properties","title":"Algebraic properties","text":"Tag Description <code>algebraic/bandaged</code> Bandaged <code>algebraic/doctrinaire</code> Doctrinaire <code>algebraic/jumbling</code> Jumbling <code>algebraic/pseudo/bandaged</code> Pseduobandaged <code>algebraic/pseudo/doctrinaire</code> Pseudodoctrinaire <code>algebraic/pseudo/jumbling</code> Pseudojumbling <code>algebraic/abelian</code> The puzzle's state space is abelian (commutative) <code>algebraic/fused</code> Fused <code>algebraic/orientations/non_abelian</code> At least one piece has a non-abelian orientation group <code>algebraic/trivial</code> Trivial <code>algebraic/weird_orbits</code> The permutation group of at least one orbit of one piece type is a group other than an alternating or symmetric group <p>Definitions</p> <ul> <li>Unbandaging is the process of splitting pieces into smaller ones</li> <li>A finite puzzle is one with finitely many pieces</li> <li>A doctrinaire puzzle is one whose moves are all always accessible (never blocked)</li> <li>A bandaged puzzle is one that is not doctrinaire, but can be unbandaged into a finite doctrinaire puzzle</li> <li>A jumbling puzzle is one that cannot be unbandaged into a finite doctrinaire puzzle</li> <li>A pseudodoctrinaire puzzle is one where the set of accessible moves of a state can be determined only from the orientations of the 1-grip pieces</li> <li>A pseudojumbling puzzle is one that cannot be unbandaged into a finite pseudodoctrinaire puzzle</li> <li>A pseudobandaged puzzle is one that is not pseudodoctrinaire, but can be unbandaged into a finite pseudodoctrinaire puzzle</li> <li>A fused puzzle is one that can be decomposed into several non-interacting puzzles, i.e. the puzzle's state space is a direct product and each generator is only from one factor</li> <li>A trivial puzzle is one whose state space can be expressed as a direct product of \"line puzzles,\" where a \"line puzzle\" is a puzzle with at most two moves available from any position</li> </ul> <p>Derived facts</p> <ul> <li>A finite puzzle is always either doctrinaire, bandaged, or jumbling</li> <li>A finite puzzle is always either pseudodoctrinaire, pseudobandaged, or pseudojumbling</li> <li>All doctrinaire puzzles are pseudodoctrinaire</li> <li>All pseudojumbling puzzles are jumbling</li> <li>Trivial puzzles are not necessarily abelian</li> <li>Trivial puzzles are not necessarily doctrinaire</li> </ul>"},{"location":"hsc/lua/tags/#cuts","title":"Cuts","text":"<p>The <code>cuts</code> tags indicate properties of the cuts of the puzzle. A puzzle may have any number of these tags.</p> Tag Description <code>cuts/depth/shallow</code> Shallow-cut <code>cuts/depth/deep</code> Deep-cut (deeper than shallow-cut, but not half-cut) <code>cuts/depth/deep/to_adjacent</code> Cut to the adjacent axis <code>cuts/depth/deep/past_adjacent</code> Cut past the adjacent axis <code>cuts/depth/deep/past_origin</code> Cut past the origin <code>cuts/depth/half</code> Half-cut (cut through the center of the puzzle) <code>cuts/stored</code> At least one stored cut <code>cuts/wedge</code> At least one wedge cut <p>Definitions</p> <ul> <li>A stored cut is a division between pieces that cannot be split by a move accessible from the solved state of the puzzle</li> <li>A wedge cut is a cut constructed piecewise from multiple (hyper)planes</li> </ul>"},{"location":"hsc/lua/tags/#categories","title":"Categories","text":"Tag Description <code>canonical</code> The puzzle is widely accepted as the \"canonical\" example for its shape and turning element (e.g., the Rubik's cube is the canonical face-turning cube) <code>meme</code> The puzzle is included as a joke and is not intended to be studied or solved"},{"location":"hsc/lua/tags/#families","title":"Families","text":"<p>See <code>tags.kdl</code> for a full list of families.</p> Tag Description <code>family/gap/sliding</code> Sliding gap puzzle (e.g., 15-puzzle) <code>family/gap/rotating</code> Rotating gap puzzle <code>family/multicore</code> Puzzle with multiple turning centers"},{"location":"hsc/lua/tags/#variants","title":"Variants","text":"<p>Variant tags are only used for puzzles that were originally invented as variations on existing puzzles.</p> Tag Type Description <code>variant/stickermod</code> puzzle Puzzle that this is a stickermod of <code>variant/shapemod</code> puzzle Puzzle that this is a shapemod of <code>variant/bump</code> Bump puzzle (e.g., Mirror Blocks) <code>variant/bandaging</code> The puzzle is a bandaging of another puzzle <p>TODO: should <code>variant/bump</code> and <code>variant/bandaging</code> also have type <code>Puzzle</code>?</p>"},{"location":"hsc/lua/tags/#attribution","title":"Attribution","text":"Tag Type Description <code>author</code> string list Author(s) of the puzzle definition file <code>inventor</code> string list Inventor(s)/designer(s) of the original physical puzzle"},{"location":"hsc/lua/tags/#miscellaneous-tags","title":"Miscellaneous tags","text":"Tag Type Description <code>solved</code> (auto) Whether the user has solved this puzzle <code>generated</code> (auto) Whether the puzzle was generated from a generator <code>builtin</code> string Version of Hyperspeedcube that the puzzle was added, if it is a built-in puzzle <code>external/gelatinbrain</code> string ID in Gelatinbrain Puzzle Simulator <code>external/hof</code> string Hall Of Fame URL <code>external/mc4d</code> Whether the puzzle exists in Magic Cube 4D <code>external/museum</code> integer ID in the TwistyPuzzles.com Museum <code>external/wca</code> string ID in the World Cube Association rankings <code>experimental</code> Whether the puzzle is experimental and so is likely to change in future versions <code>big</code> Whether the puzzle may take a long time to load"},{"location":"hsc/lua/tags/#specification","title":"Specification","text":"<p>A Lua tag specification is a table specifying a set of tags for a puzzle or other tagged object.</p> <p>The sequence values of the table must be strings. If a string does not start with <code>!</code>, then that tag is assigned the value <code>true</code>. If a string starts with <code>!</code>, then it is a negated tag: the <code>!</code> is removed and the tag specified in the rest of the string is assigned the value <code>false</code>.</p> <p>Non-sequence keys must be strings containing tag names. The value of each entry may be a tag value of the appropriate type, or table containing a specification for subtags.</p> <p>Tag names may contain multiple <code>/</code>-separated components, which is used to specify subtags.</p> <p>Generated puzzles inherit tags from their generators, unless explicitly overridden with a negated tag.</p>"},{"location":"hsc/lua/tags/#types","title":"Types","text":"<p>Booleans, integers, and strings are all specified using the corresponding Lua types.</p> <p>A string list may be specified as a single string (such as <code>\"Andrew Farkas\"</code>) table containing a sequence of strings (such as <code>{\"Andrew Farkas\", \"Milo Jacquet\"}</code>).</p> <p>A puzzle name is specified using a string containing its ID.</p>"},{"location":"hsc/lua/tags/#expected-tags","title":"Expected tags","text":"<p>Many tags are expected to be specified on all puzzles, to ensure that nothing is forgotten and that new tags are added to existing puzzles. Hyperspeedcube will emit a warning when loading a puzzle definition that leaves certain tags unspecified. See <code>tags_template.lua</code>.</p>"},{"location":"hsc/lua/tags/#examples","title":"Examples","text":"Example tag specification<pre><code>local tags = {\n  builtin = '1.0.0',\n  external = {\n    gelatinbrain = '3.1.2', -- external/gelatinbrain\n    '!hof',                 -- external/hof = false\n    museum = 7629,          -- external/museum\n    wca = '333',            -- external/wca\n  },\n\n  author = { \"Andrew Farkas\", \"Milo Jacquet\" }, -- string list (2)\n  inventor = \"Ern\u0151 Rubik\",                      -- string list (1)\n\n  'shape/3d/platonic/cube',\n  algebraic = {\n    'doctrinaire', 'pseudo/doctrinaire',\n    '!fused', '!orientations/non_abelian', '!trivial', '!weird_orbits',\n  },\n  axes = { '3d/elementary/cubic', '!hybrid', '!multicore' },\n  colors = { '!multi_facet_per', '!multi_per_facet' },\n  cuts = { depth = { 'shallow' }, '!stored', '!wedge' },\n  turns_by = { 'face', 'facet' },\n  '!experimental',\n  '!family',\n  '!variant',\n  '!meme',\n  '!shapeshifting',\n}\n</code></pre>"},{"location":"hsc/lua/versioning/","title":"Puzzle versioning","text":"<p>Puzzle versions use a subset of Semantic Versionsing 2.0.0.</p> <p>A puzzle version is a string consisting of one, two, or three nonnegative integers, separated by <code>.</code>. The first integer is the major version, the second integer is the minor version, and the third integer is the patch version. The minor and patch versions are assumed to be zero when omitted.</p> <p>Examples</p> <ul> <li><code>1.2.3</code> has a major version of <code>1</code>, minor version of <code>2</code>, and patch version of <code>3</code></li> <li><code>0.0.1</code> has a major version of <code>0</code>, minor version of <code>0</code>, and patch version of <code>1</code></li> <li><code>0.6</code> has a major version of <code>0</code>, minor version of <code>6</code>, and patch version of <code>0</code></li> <li><code>2</code> has a major version of <code>2</code>, minor version of <code>0</code>, and patch version of <code>0</code></li> </ul> <ul> <li>The major version should increment whenever changes are made to the puzzle definition that break log file compatibility.</li> <li>The minor version should increment whenever changes are made to the puzzle definition that break scramble compatibility.</li> <li>The patch version should increment whenever any other changes are made to the puzzle definition.</li> </ul> <p>Whenever one version increments, the lower ones should be reset to zero.</p>"},{"location":"hsc/lua/geometry/blade/","title":"Blade","text":"<p>A blade is a geometric algebra primitive that can be used to represent a vector, a point, a line, a hyperplane, or numerous other geometric objects. Hyperspeedcube uses blades from the Projective Geometric Algebra, but knowledge of geometric algebra is not required in order to use the API effectively.</p> <p>Blades cannot be mutated once constructed. To modify a blade, you must construct a new blade and then replace the old one.</p> <p>The examples on this page assume 3D, but the same API works in other dimensions.</p>"},{"location":"hsc/lua/geometry/blade/#constructors","title":"Constructors","text":"<p>All these constructors return a blade with the number of dimensions of the currently active space, and therefore can only be called in a context with a global number of dimensions (such as during the construction of a puzzle). They produce an error if it is called when there is not a global number of dimensions.</p>"},{"location":"hsc/lua/geometry/blade/#vec","title":"<code>vec()</code>","text":"<p><code>vec()</code> constructs a vector and can be called in any of several ways:</p> <ul> <li>No arguments. Calling <code>vec()</code> with no arguments returns the zero vector. For example, <code>vec()</code> constructs the blade \\(0\\), which represents the vector \\(\\langle 0, 0, 0 \\rangle\\).</li> <li>Components. Calling <code>vec()</code> with multiple numbers constructs a vector with those components. For example, <code>vec(10, 20, 30)</code> constructs the blade \\(10x+20y+30z\\), which represents the vector \\(\\langle 10, 20, 30 \\rangle\\).</li> <li>Axis name. Calling <code>vec()</code> with a single-character axis string constructs a unit vector along that axis. For example, <code>vec('y')</code> constructs the blade \\(y\\), which represents the vector \\(\\langle 0, 1, 0 \\rangle\\).</li> <li>Table. Calling <code>vec()</code> with a table as its argument assigns each key-value pair to a component of the vector. The key may be a number or a string, using the same mapping as vector component access. For example, <code>vec{10, z = 30}</code><sup>1</sup> constructs the blade \\(10x+30y\\), which represents the vector \\(\\langle 10, 0, 30 \\rangle\\).</li> <li>Vector. Calling <code>vec()</code> with an existing vector will return the vector unmodified.</li> <li>Point. Calling <code>vec()</code> with an existing point will unitize the point then return its coordinates as a vector.</li> </ul> <p>Extra components beyond the number of dimensions of the space are ignored.</p>"},{"location":"hsc/lua/geometry/blade/#point","title":"<code>point()</code>","text":"<p><code>point()</code> constructs a point, using the same argument structure as <code>vec()</code>. The returned point is unitized.</p>"},{"location":"hsc/lua/geometry/blade/#blade_1","title":"<code>blade()</code>","text":"<p><code>blade()</code> constructs a blade and can be called in either of two ways:</p> <ul> <li>Scalar. Calling <code>blade()</code> with a scalar value returns a scalar blade. For example, <code>blade(6.5)</code> returns the blade \\(6.5\\).</li> <li>Blade. Calling <code>blade()</code> with an existing point, vector, or blade returns the value unmodified.</li> </ul>"},{"location":"hsc/lua/geometry/blade/#vectors","title":"Vectors","text":"<p>A vector is a direction in space and an associated magnitude. Vectors can be constructed using <code>vec()</code>. Vectors are also constructed automatically by functions that require them, so you can often omit the call to <code>vec()</code>.</p> <p>Vectors are represented as 1-blades with no e<sub>0</sub> component.</p>"},{"location":"hsc/lua/geometry/blade/#vector-component-access","title":"Vector component access","text":"<p>Vectors can be indexed by positive integers or single-character strings. The following single-letter and single-digit strings are recognized, uppercase or lowercase:</p> <ul> <li><code>my_vector.X</code> = <code>my_vector[1]</code> = X axis</li> <li><code>my_vector.Y</code> = <code>my_vector[2]</code> = Y axis</li> <li><code>my_vector.Z</code> = <code>my_vector[3]</code> = Z axis</li> <li><code>my_vector.W</code> = <code>my_vector[4]</code> = W axis (4th dimension)</li> <li><code>my_vector.V</code> = <code>my_vector[5]</code> = V axis (5th dimension)</li> <li><code>my_vector.U</code> = <code>my_vector[6]</code> = U axis (6th dimension)</li> <li><code>my_vector[7]</code> = 7th dimension</li> </ul> Examples of vector indexing<pre><code>local my_vector = vec(10, 20, 30)\nassert(my_vector.x == 10)\nassert(my_vector.Y == 20)\nassert(my_vector[3] == 30)\n</code></pre>"},{"location":"hsc/lua/geometry/blade/#vector-fields","title":"Vector fields","text":"<p>Vectors have the following fields:</p> <ul> <li><code>.unit</code> is the normal vector in the same direction as the original vector</li> <li><code>.mag2</code> is the squared magnitude of the vector</li> <li><code>.mag</code> is the magnitude of the vector</li> </ul> <p>See Blade fields for a full list.</p>"},{"location":"hsc/lua/geometry/blade/#vector-methods","title":"Vector methods","text":"<p>Vectors have all the same methods as general blades. Additionally, they have the following method:</p> <ul> <li><code>:cross(other)</code> returns the 3D cross product between the vector and another vector <code>other</code>, ignoring components other than XYZ</li> </ul>"},{"location":"hsc/lua/geometry/blade/#vector-operations","title":"Vector operations","text":"<p>Vectors support the following operations:</p> <ul> <li><code>vector + vector</code></li> <li><code>vector - vector</code></li> <li><code>vector * float</code></li> <li><code>float * vector</code></li> <li><code>vector / float</code></li> <li><code>-vector</code></li> <li><code>vector == vector</code> (uses approximate floating-point comparison)</li> <li><code>vector ~= vector</code> (uses approximate floating-point comparison)</li> <li><code>type(vector)</code> (returns <code>'blade'</code>)</li> <li><code>tostring(vector)</code></li> <li><code>pairs(vector)</code></li> </ul> <p>For <code>+</code> and <code>-</code>, either of the two vectors may be substituted for a value of any other type and it will be converted to a vector using <code>vec(...)</code>.</p>"},{"location":"hsc/lua/geometry/blade/#points","title":"Points","text":"<p>A point is a point in space. Points can be constructed using <code>point()</code>. Points are also constructed automatically by functions that require them, so you can often omit the call to <code>point()</code>.</p> <p>Points are represented as 1-blades, with an e<sub>0</sub> component.</p> <p>See General blades for fields, methods, and operations on points.</p> <p>Operations on points</p> <p>Be very cautious when doing operations on points. You can add two points to compute a position between them, but ensure that they are unitized first.</p>"},{"location":"hsc/lua/geometry/blade/#point-component-access","title":"Point component access","text":"<p>Point component access</p> <p>Accessing components of points (such as <code>p.x</code>) does not return a coordinate of the point unless the point is unitized: use either <code>p.unit.x</code> or <code>p.x / p.e0</code>.</p> <p>Once a point has been unitized using <code>.unit</code> (see Blade fields), its components can be accessed the same as a vector. The e<sub>0</sub> component can be accessed with <code>.e0</code>.</p>"},{"location":"hsc/lua/geometry/blade/#general-blades","title":"General blades","text":""},{"location":"hsc/lua/geometry/blade/#blade-indexing","title":"Blade indexing","text":"<p>Indexing a blade using a string of vector index characters, with the addition of <code>0</code> for the e<sub>0</sub> component. Additionally, the characters <code>s</code>, <code>e</code>, <code>n</code>, <code>_</code>, and <code></code> (space) are ignored. By combining these, any component of the blade is accessible.</p> Examples of blade component access<pre><code>print(my_scalar_blade.s) -- scalar component\n\nprint(my_bivector_blade.xy) -- xy bivector component\nassert(my_bivector_blade.xy == -my_bivector_blade.yx)\n\nprint(my_trivector_blade.e0_xy) -- e\u2080xy trivector component\n</code></pre>"},{"location":"hsc/lua/geometry/blade/#blade-fields","title":"Blade fields","text":"<p>Blades have the following fields:</p> <ul> <li><code>.ndim</code> is the number of dimensions of the space containing the blade</li> <li><code>.grade</code> is the grade of the blade (1)</li> <li><code>.antigrade</code> is the antigrade of the blade (2)</li> <li><code>.dual</code> is the metric dual of the blade</li> <li><code>.antidual</code> is the metric antidual of the blade</li> <li><code>.complement</code> is the right complement of the blade</li> <li><code>.unit</code> returns the unitization of a blade if it has nonzero weight, or its bulk normalization if it has zero weight (3)</li> <li><code>.mag2</code> is the geometric norm squared (4)</li> <li><code>.mag</code> is the geometric norm (5)</li> <li><code>.bulk</code> is the bulk of the blade (6)</li> <li><code>.weight</code> is the weight of the blade (7)</li> </ul> <ol> <li>A vector or point always has grade <code>1</code>, a bivector has grade <code>2</code>, etc.</li> <li>A hyperplane always has antigrade <code>1</code>.</li> <li>For a vector, this is a unit vector in the same direction. For a point, this is a unitized point whose components are the point's coordinates.</li> <li>For a vector, this is the squared length of the vector.</li> <li>For a vector, this is the length of the vector.</li> <li>The bulk is a blade comprised of only components with an e<sub>0</sub> factor.</li> <li>The bulk is a blade comprised of only components without an e<sub>0</sub> factor.</li> </ol> <p>Useful constructions</p> <ul> <li><code>.bulk.mag</code> is the bulk norm of the blade</li> <li><code>.weight.mag</code> is the weight norm of the blade</li> <li><code>b / b.weight.mag</code> is the unitization of a blade <code>b</code></li> </ul>"},{"location":"hsc/lua/geometry/blade/#blade-methods","title":"Blade methods","text":"<p>Blades have the following methods:</p> <ul> <li><code>:projected_to(other)</code> returns the component of the blade that is parallel to another blade <code>other</code> (i.e., its projection onto <code>other</code>)</li> <li><code>:rejected_from(other)</code> returns the component of the blade that is perpendicular to another blade <code>other</code></li> <li><code>:wedge(other)</code> returns the wedge product between two blades</li> <li><code>:antiwedge(other)</code> returns the antiwedge product between two blades</li> <li><code>:dot(other)</code> returns the dot product between two blades</li> <li><code>:antidot(other)</code> returns the antidot product between two blades</li> </ul>"},{"location":"hsc/lua/geometry/blade/#blade-operations","title":"Blade operations","text":"<p>Blades support the following operations:</p> <ul> <li><code>blade + blade</code></li> <li><code>blade - blade</code></li> <li><code>blade * float</code></li> <li><code>float * blade</code></li> <li><code>blade / float</code></li> <li><code>-blade</code></li> <li><code>blade ^ blade</code> (wedge product)</li> <li><code>blade &amp; blade</code> (antiwedge product)</li> <li><code>~blade</code> (right complement)</li> <li><code>blade == blade</code> (approximate floating-point equality)</li> <li><code>blade ~= blade</code> (approximate floating-point inequality)</li> <li><code>blade[index]</code> (see Blade indexing)</li> <li><code>type(blade)</code> returns <code>'blade'</code></li> <li><code>tostring(blade)</code></li> <li><code>pairs(blade)</code> iterates over the key/value pairs for a vector or point</li> </ul> Example using <code>pairs(blade)</code> <pre><code>local v = vec(10, 20, 30)\nfor i, x in pairs(v) do\n  print(i) -- 1, 2, 3\n  print(x) -- 10, 20, 30\nend\n</code></pre> <ol> <li> <p>Lua syntax allows omitting the parentheses when calling a function with a table literal or string literal as its only argument. For example, you can write <code>vec{10, z = 30}</code> instead of <code>cd({10, z = 30})</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/lua/geometry/hyperplane/","title":"Hyperplane","text":"<p>A hyperplane is an oriented flat \\((d-1)\\)-dimensional surface in \\(d\\)-dimensional space. The orientation of a hyperplane is determined by its normal vector; to flip a hyperplane's orientation, negate its normal vector.</p> <p>Hyperplanes are also constructed automatically by functions that require them, so you can often omit the call to the constructor <code>plane()</code>.</p> <p>Hyperplanes cannot be mutated once constructed. To modify a hyperplane, you must construct a new hyperplane and then replace the old one.</p> <p>The examples on this page assume 3D, but the same API works in other dimensions.</p>"},{"location":"hsc/lua/geometry/hyperplane/#constructors","title":"Constructors","text":"<p>All these constructors return a hyperplane with the number of dimensions of the currently active space, and therefore can only be called in a context with a global number of dimensions (such as during the construction of a puzzle). They produce an error if it is called when there is not a global number of dimensions.</p>"},{"location":"hsc/lua/geometry/hyperplane/#plane","title":"<code>plane()</code>","text":"<p><code>plane()</code> constructs a hyperplane and can be called in any of several ways:</p> <ul> <li>Table. There are several ways to construct a plane using a table:<ul> <li>Calling <code>plane{normal: vector, distance: number}</code>[^omit-braces] constructs the plane with normal vector <code>normal</code> and distance from the origin <code>distance</code>.</li> <li>Calling <code>plane{normal: vector, point: point}</code> constructs the plane with normal vector <code>normal</code> that passes through the point <code>point</code>.</li> <li>Calling <code>plane{pole: vector|point}</code> constructs the plane with <code>pole</code> that passes through the point <code>pole</code>. <code>plane{pole = p}</code> is equivalent to <code>plane{normal = p, point = p}</code> or <code>plane{normal = p, distance = p.mag}</code>.</li> </ul> </li> <li>Normal vector and distance. Calling <code>plane()</code> with a vector and a number constructs the plane with the given normal vector and distance from the origin. <code>plane(n, d)</code> is equivalent to <code>plane{normal = n, distance = d}</code>.</li> <li>Pole vector. Calling <code>plane()</code> with a vector or point constructs the plane with that vector as a normal vector that passes through that point. <code>plane(p)</code> is equivalent to <code>plane{pole = p}</code>.</li> <li>Plane. Calling <code>plane()</code> with a blade representing a hyperplane returns the blade unchanged.</li> </ul> Examples of plane construction<pre><code>-- plane through point (2, -3, 6) with normal vector (2/7, -3/7, 6/7)\nplane(vec(2, -3, 6))\nplane(point(2, -3, 6))\n\n-- plane through point (1, 0, 0) perpendicular to the X axis\nplane('x')\nplane{pole = vec(1)} -- note the curly braces!\nplane{normal = vec(3), distance = 1}\n\n-- plane through point (1, 0, 0) perpendicular to the X axis, but facing the other way\n-plane('x')\nplane(-vec('x'), -1)\n\n-- plane through the origin with normal vector (0, 0, 1)\nplane('z', 0)\nplane{normal = 'z', point = vec()}\nplane{normal = 'z', distance = 0}\n</code></pre>"},{"location":"hsc/lua/geometry/hyperplane/#fields","title":"Fields","text":"<p>Hyperplanes have the following fields:</p> <ul> <li><code>.ndim</code> is the number of dimensions of the space containing the blade</li> <li><code>.flip</code> is the same hyperplane, facing the opposite direction</li> <li><code>.normal</code> is the (normalized) normal vector of the hyperplane</li> <li><code>.distance</code> is the minimum distance of the hyperplane from the origin</li> <li><code>.blade</code> is the blade representing the hyperplane</li> <li><code>.region</code> is the region of space bounded on the side of the hyperplane facing away from the normal vector</li> </ul>"},{"location":"hsc/lua/geometry/hyperplane/#methods","title":"Methods","text":"<p>Hyperplanes have the following methods:</p> <ul> <li><code>:signed_distance()</code></li> </ul>"},{"location":"hsc/lua/geometry/hyperplane/#hyperplanesigned_distance","title":"<code>hyperplane:signed_distance()</code>","text":"<p><code>hyperplane:signed_distance()</code> returns the signed distance of a point to a hyperplane. It takes one argument: a point. The distance returned is zero if the point is on the hyperplane, positive if the point is in the direction of the hyperplane's normal vector, or negative if the point is in the opposite direction.</p>"},{"location":"hsc/lua/geometry/hyperplane/#operations","title":"Operations","text":"<p>Hyperplanes support the following operations:</p> <ul> <li><code>hyperplane == hyperplane</code> (approximate floating-point equality)</li> <li><code>hyperplane ~= hyperplane</code> (approximate floating-point inequality)</li> <li><code>type(hyperplane)</code> returns <code>'hyperplane'</code></li> <li><code>tostring(hyperplane)</code></li> </ul>"},{"location":"hsc/lua/geometry/orbit/","title":"Orbit","text":"<p>An orbit is an iterator over all the unique locations of a set of transformable objects under some symmetry.</p>"},{"location":"hsc/lua/geometry/orbit/#constructors","title":"Constructors","text":""},{"location":"hsc/lua/geometry/orbit/#symmetryorbit","title":"<code>symmetry:orbit()</code>","text":"<p>Calling the <code>:orbit()</code> method on a symmetry with one or more transformable objects constructs an orbit of those objects. For example, <code>cd'bc3':orbit(vec('x'), vec('y'))</code> constructs an orbit containing 12 elements, since there are twelve unique symmetric locations for the (ordered) pair of vectors \\((\\langle 1,0,0 \\rangle, \\langle 0,1,0 \\rangle)\\) on a cube.</p>"},{"location":"hsc/lua/geometry/orbit/#fields","title":"Fields","text":"<ul> <li><code>.symmetry</code> is the symmetry used to construct the orbit</li> <li><code>.init</code> is a sequential table containing the elements used to construct the orbit</li> <li><code>.names</code> is a sequential table containing names assigned to elements using <code>:named()</code></li> </ul>"},{"location":"hsc/lua/geometry/orbit/#methods","title":"Methods","text":""},{"location":"hsc/lua/geometry/orbit/#orbitget","title":"<code>orbit:get()</code>","text":"<p><code>orbit:get()</code> returns noe step of the iteration. It takes a single argument: an index.</p> <p>The first value returned is always the transform for the orbit element. The remaining values are the transformed objects.</p> Example using orbit:get()<pre><code>local sym = cd'bc3'\nlocal axes_orbit = sym:orbit(sym.oox.unit)\nlocal tranform1, axis1 = axes_orbit:get(1)\nlocal tranform2, axis2 = axes_orbit:get(2)\nlocal tranform3, axis3 = axes_orbit:get(3)\n</code></pre>"},{"location":"hsc/lua/geometry/orbit/#orbitintersection","title":"<code>orbit:intersection()</code>","text":"<p>See <code>orbit:intersection()</code>.</p>"},{"location":"hsc/lua/geometry/orbit/#orbititer","title":"<code>orbit:iter()</code>","text":"<p><code>orbit:iter()</code> returns a new identical orbit that can be used for iteration. Once an orbit has been iterated over in a <code>for</code> loop, it cannot be used again. See Iteration.</p>"},{"location":"hsc/lua/geometry/orbit/#orbitnamed","title":"<code>orbit:named()</code>","text":"<p><code>orbit:named()</code> returns a new orbit with names assigned to the elements. It takes as its only argument a table with a specific format.</p> <p>The keys of the table are the names to assign, and the values are a sequence of mirror reflections, optionally ending with the name of an initial element.</p> <p>An example will make this clearer:</p> Example using orbit:named()<pre><code>local sym = cd'bc3'\nlocal named_orbit = sym:orbit(sym.oox.unit):named({\n  F = {}, -- oox\n  U = {3, 'F'},\n  R = {2, 'U'},\n  L = {1, 'R'},\n  D = {2, 'L'},\n  B = {3, 'D'},\n})\n</code></pre> <p>In this example, the initial element of the orbit (<code>sym.oox.unit</code>) is assigned the name <code>F</code>, since its mirror sequence is the empty table <code>{}</code>. Starting with <code>F</code>, applying the third mirror brings us to a new element, which is assigned the name <code>U</code> (since <code>U</code> corresponds to the sequence <code>{3, 'F'}</code>; i.e., starting with <code>F</code>, reflect across mirror 3). <code>R</code> is generated from <code>U</code>, etc.</p> <p>This example also specifies an order for the elements: <code>R</code> is the first element, <code>L'</code> is the second, etc.</p> <p>This could also be written like this, using longer mirror sequences instead of referring to other elements:</p> Example using orbit:named() with no named references<pre><code>local sym = cd'bc3'\nlocal named_orbit = sym:orbit(sym.oox.unit):named({\n  F = {}, -- oox\n  U = {3},\n  R = {2, 3},\n  L = {1, 2, 3},\n  D = {2, 1, 2, 3},\n  B = {3, 2, 1, 2, 3},\n})\n</code></pre> <p>You should rarely write one of these tables by hand. There are many of them bundled with the default Lua files in Hyperspeedcube, and you can generate new ones using the Developer Tools window in Hyperspeedcube.</p>"},{"location":"hsc/lua/geometry/orbit/#orbitprefixed","title":"<code>orbit:prefixed()</code>","text":"<p><code>orbit:prefixed()</code> returns a new orbit with a prefix prepended to each name in the orbit. It takes as its only argument an optional string to prepend. If no argument is supplied, then the orbit is returned unmodified.</p> Example using orbit:named()<pre><code>local sym = cd'bc3'\nlocal named_orbit = sym:orbit(sym.oox.unit):named({\n  F = {}, -- oox\n  U = {3, 'F'},\n  R = {2, 'U'},\n  L = {1, 'R'},\n  D = {2, 'L'},\n  B = {3, 'D'},\n})\nlocal orbit1 = named_orbit -- F, U, R, ...\nlocal orbit2 = named_orbit:prefixed(nil) -- F, U, R, ...\nlocal orbit3 = named_orbit:prefixed('Cubic') -- CubicF, CubicU, CubicR, ...\n</code></pre>"},{"location":"hsc/lua/geometry/orbit/#orbitunion","title":"<code>orbit:union()</code>","text":"<p>See <code>orbit:union()</code>.</p>"},{"location":"hsc/lua/geometry/orbit/#operations","title":"Operations","text":"<p>Orbits support the following operations:</p> <ul> <li><code>#orbit</code> returns the length of the orbit; i.e., the number of iterations</li> <li><code>orbit[index]</code> returns the first transformed object at the given index in the orbit</li> <li><code>type(orbit)</code> returns <code>'orbit'</code></li> </ul>"},{"location":"hsc/lua/geometry/orbit/#iteration","title":"Iteration","text":"<p>Orbit objects can be used in <code>for</code> loops. When iterated over, they yield a transform from the symmetry group, the sequence of initial objects transformed by that symmetry (as separate values, not as a table), and lastly a name (or <code>nil</code> if no name has been assigned for the element).</p> <p>There may be multiple transforms that produce the same element of the orbit; it is unspecified which one will used when iterating.</p> Examples iterating over orbits<pre><code>local symmetries = require('symmetries')\nlocal sym = cd'bc3'\n\nfor t, v1, name in sym:orbit(sym.oox):named(symmetries.cubic.FACE_NAMES_LONG) do\n  assert(v1 == t:transform(sym.oox))\n  print(v1) -- +X, -X, +Y, -Y, +Z, -Z\n  print(name) -- Right, Left, Up, Down, Front, Back\nend\n\nfor t, face_vector, edge_vector in sym:orbit(sym.oox, sym.oxo) do\n  assert(face_vector == t:transform(sym.oox))\n  assert(edge_vector == t:transform(sym.oxo))\n  -- no names, because we didn't call `:named()`\nend\n</code></pre> <p>It is good practice to call <code>:iter()</code> on a symmetry when using it in a <code>for</code> loop, unless the symmetry is constructed inline in a <code>for</code> loop.</p> Examples of when to use orbit:iter()<pre><code>local sym = cd'bc3'\n\n-- This is ok, because the symmetry is constructed inline\nfor _, v in sym:orbit(sym.oox) do\n  print(v)\nend\n\n-- This is ok, because we call `:iter()`\nlocal orbit1 = sym:orbit(sym.oox)\nfor _, v in orbit1:iter() do\n  print(v)\nend\n\n-- This is questionable but will work, because we are only using the orbit once\nlocal orbit2 = sym:orbit(sym.oox)\nfor _, v in orbit2 do\n  print(v)\nend\n\n-- This is bad! We are using the same orbit object twice\nfor _, v in orbit2 do\n  -- The contents of this loop will not be executed\n  -- because the iterator has been used up\n  print(v)\nend\n\n-- This is ok! Calling `:iter()` always gives a fresh iterator\nfor _, v in orbit2:iter() do\n  print(v)\nend\n\n-- This is also ok! Functions that take an orbit as a parameter implicitly call `:iter()`\npuzzle:carve(orbit2)\n</code></pre>"},{"location":"hsc/lua/geometry/region/","title":"Region","text":"<p>A region is a subset of a space bounded by hyperplanes. They are most commonly used to identify pieces.</p>"},{"location":"hsc/lua/geometry/region/#constants","title":"Constants","text":"<p>The following global constants contain regions:</p> <ul> <li><code>REGION_ALL</code> is the region containing all of space</li> <li><code>REGION_NONE</code> is the region containing none of space</li> </ul>"},{"location":"hsc/lua/geometry/region/#constructors","title":"Constructors","text":""},{"location":"hsc/lua/geometry/region/#axis","title":"<code>axis()</code>","text":"<p>Calling an axis as a function returns a region. It can be called in any of several ways:</p> <ul> <li>Single layer. Calling an axis with a single layer index constructs a region bounding that layer.</li> <li>Two layers. Calling an axis with two layer indices constructs a region bounding that layer range.</li> <li>Layer list. Calling an axis with a sequential table of layer indices constructs a region bounding the union of all of those layers.</li> <li>Layer mask string. Calling an axis with a layer mask string constructs a region bounding the union of the layers specified by the string. If the string is a single asterisk <code>*</code> then all layers are included.</li> </ul> Examples using axis()<pre><code>-- Add 2 axes, each with 5 layers.\nself.axes:add(vec('x'), {1/2, 1/4, 0, -1/2, -1/4})\nself.axes:add(vec('y'), {1/2, 1/4, 0, -1/2, -1/4})\nself.axes:autoname()\n\nlocal region1 = self.axes.A(1) -- first layer of axis A\nlocal region2 = self.axes.B('*') -- all 3 layers of axis B\nlocal region3 = self.axes.B(1, 3) -- layers 1 to 3 of axis B\nlocal region4 = self.axes.A({1, 3, 5}) -- layers 1, 3, and 5 of axis A\nlocal region5 = self.axes.A('1..-2') -- layers 1 to 4 of axis A\n</code></pre>"},{"location":"hsc/lua/geometry/region/#hyperplaneregion","title":"<code>hyperplane.region</code>","text":"<p><code>hyperplane.region</code> returns the region bounded by a hyperplane, on the side its normal vector is pointing away from.</p> Examples of hyperplane.region<pre><code>local region1 = plane('x').region -- X &lt;= 1\nlocal region2 = plane('x').flip.region -- X &gt;= 1\nlocal region3 = ~plane('x').region -- X &gt;= 1\n</code></pre>"},{"location":"hsc/lua/geometry/region/#orbitintersection","title":"<code>orbit:intersection()</code>","text":"<p><code>orbit:intersection()</code> returns the intersection of all regions in an orbit. Each element of the orbit must be a single region. Names are ignored.</p> Examples of orbit:intersection()<pre><code>-- region inside a unit cube\nlocal region1 = cd'bc3':orbit(plane('x').region):intersection()\n</code></pre>"},{"location":"hsc/lua/geometry/region/#orbitunion","title":"<code>orbit:union()</code>","text":"<p><code>orbit:union()</code> returns the union of all regions in an orbit. Each element of the orbit must be a single region. Names are ignored.</p> Examples of orbit:union()<pre><code>-- region outside a unit cube\nlocal region1 = cd'bc3':orbit(plane('x').flip.region):union()\n</code></pre>"},{"location":"hsc/lua/geometry/region/#fields","title":"Fields","text":"<p>Regions have no fields.</p>"},{"location":"hsc/lua/geometry/region/#methods","title":"Methods","text":"<p>Regions have the following methods:</p> <ul> <li><code>:contains(point)</code> returns whether the region contains a point</li> </ul>"},{"location":"hsc/lua/geometry/region/#operations","title":"Operations","text":"<p>Regions support the following operations:</p> <ul> <li><code>region &amp; region</code> (intersection)</li> <li><code>region | region</code> (union)</li> <li><code>region ~ region</code> (symmetric difference)</li> <li><code>~region</code> (complement)</li> <li><code>type(region)</code> returns <code>'region'</code></li> <li><code>tostring(region)</code></li> </ul>"},{"location":"hsc/lua/geometry/space/","title":"Space","text":"<p>A space is a finite-dimensional Euclidean space in which a puzzle can be constructed. The currently active space is stored in the global variable <code>SPACE</code>. A space is active during puzzle construction.</p>"},{"location":"hsc/lua/geometry/space/#fields","title":"Fields","text":"<p>Spaces have the following field:</p> <ul> <li><code>.ndim</code> is the number of dimensions of the space.</li> </ul>"},{"location":"hsc/lua/geometry/space/#methods","title":"Methods","text":"<p>Spaces have no methods.</p>"},{"location":"hsc/lua/geometry/space/#operations","title":"Operations","text":"<p>Spaces support the following operations:</p> <ul> <li><code>type(space)</code> returns <code>'space'</code></li> <li><code>tostring(space)</code></li> </ul>"},{"location":"hsc/lua/geometry/symmetry/","title":"Symmetry","text":"<p>A symmetry is a group of transformations in space. Each element of the symmetry group is represented as a transform.</p> <p>Coxeter groups</p> <p>The symmetry groups of most puzzle shapes are Coxeter groups. It's highly recommended that you learn about Coxeter groups and their construction using mirror planes before reading the rest of this page. The section titled Symmetries of the cube in the excellent article Building 4D polytopes by Mikael Hvidtfeldt Christensen is a good primer, and the interactive demos with three planes are very helpful references.</p>"},{"location":"hsc/lua/geometry/symmetry/#constructors","title":"Constructors","text":""},{"location":"hsc/lua/geometry/symmetry/#cd","title":"<code>cd()</code>","text":"<p><code>cd()</code> constructs a Coxeter group. It takes two arguments: a Coxeter group description and an optional basis.</p>"},{"location":"hsc/lua/geometry/symmetry/#coxeter-group-description","title":"Coxeter group description","text":"<p>The Coxeter group description is either of the following:</p> <ul> <li>Table of branch labels. Calling <code>cd()</code> with a table containing a sequence of positive integers constructs group corresponding to the linear Coxeter-Dynkin diagram with those branch labels.</li> <li>Coxeter group name. Calling <code>cd()</code> with the name of a Coxeter group constructs that Coxeter group. The name is case-insensitive and must consist of one or two letters followed by a number.</li> </ul> <p>The table of branch labels is similar to a [Schl\u00e4fli symbol]. For example, <code>cd{4, 3}</code> is the symmetry group of a cube, and is equivalent to <code>cd'b3'</code>, <code>cd'c3'</code>, and <code>cd'bc3'</code>.<sup>2</sup></p> <p>Here is a list of the names for the finite Coxeter groups:</p> <ul> <li><code>a2</code>, <code>a3</code>, <code>a4</code>, ... (simplical symmetries)</li> <li><code>bc2</code>, <code>bc3</code>, <code>bc4</code>, ... (hypercubic symmetries)<ul> <li>equivalently: <code>b2</code>, <code>b3</code>, <code>b4</code>, ...</li> <li>equivalently: <code>c2</code>, <code>c3</code>, <code>c4</code>, ...</li> </ul> </li> <li><code>d4</code>, <code>d5</code>, <code>d6</code>, ... (demicubic symmetries)</li> <li><code>e6</code>, <code>e7</code>, <code>e8</code></li> <li><code>f4</code> (24-cell symmetry)</li> <li><code>g2</code> (hexagonal symmetry)</li> <li><code>h2</code>, <code>h3</code>, <code>h4</code> (pentagonal, dodecahedral/icosahedral, and 120-cell/600-cell symmetries)</li> <li><code>i2</code>, <code>i3</code>, <code>i4</code>, ... (polygonal symmetries)</li> </ul> <p>This diagram describes the Coxeter groups graphically, with labels representing the indices of the nodes in the program<sup>1</sup>:</p> <p></p>"},{"location":"hsc/lua/geometry/symmetry/#coxeter-group-basis","title":"Coxeter group basis","text":"<p>The basis for a Coxeter group may be specified as a string of axis names (such as <code>'yzw'</code>) or a table of vectors (such as <code>{vec(1, 2), vec(-2, 1)}</code>). In either case, the number of vectors specified must be equal to the number of mirrors in the Coxeter group. Vectors are normalized before constructing the Coxeter group so they do not need to be normalized, but they must all be nonzero and mutually perpendicular.</p> Example using cd()<pre><code>local sym\n\nsym = cd'a5' -- pentagonal symmetry in the XY plane (first mirror is along X)\nsym = cd{5} -- pentagonal symmetry in the XY plane (first mirror is along X)\nsym = cd('a6', 'yz') -- hexagonal symmetry in YZ plane (first mirror is along Y)\nsym = cd('a7', {vec(1, 2), vec(-2, 1)}) -- heptagonal symmetry in XY plane (first mirror is along `vec(1, 2)`)\n\nsym = cd'bc3' -- cubic symmetry in the XYZ hyperplane (first mirror is along X)\nsym = cd{4, 3} -- cubic symmetry in the XYZ hyperplane (first mirror is along X)\nsym = cd('bc3', 'wyz') -- cubic symmetry in WYZ hyperplane (first mirror is along W)\n</code></pre>"},{"location":"hsc/lua/geometry/symmetry/#symmetry_1","title":"<code>symmetry()</code>","text":"<p><code>symmetry()</code> constructs a group from generators. It takes a single argument: a sequential table of generator transforms. Twists are automatically converted to transforms.</p> <p>The fields <code>.mirror_vectors</code>, <code>.chiral</code>, and <code>.is_chiral</code> and the method <code>:vec()</code> are not supported on symmetries constructed using <code>symmetry()</code>.</p>"},{"location":"hsc/lua/geometry/symmetry/#fields","title":"Fields","text":"<p>Symmetries have the following fields:</p> <ul> <li><code>.ndim</code> is the minimum number of dimensions required to contain the symmetry</li> <li><code>.mirror_vectors</code> is a table of vectors, each corresponding to one of the mirror transformations that together generate the group</li> <li><code>.chiral</code> is the canonical chiral subgroup of the symmetry; i.e., the symmetry which is the same as this one but excluding reflections</li> <li><code>.is_chiral</code> is <code>true</code> if the symmetry is chiral (i.e., it does not contain any reflections), or <code>false</code> otherwise</li> </ul> Example using mirror vectors of a symmetry<pre><code>local mirror_vectors = cd'bc3'.mirror_vectors\nassert(#mirror_vectors == 3)\nassert(mirror_vectors[1] == vec(1))\nassert(mirror_vectors[2] == vec(-1, 1) / sqrt(2))\nassert(mirror_vectors[3] == vec(0, -1, 1) / sqrt(2))\n</code></pre> <p>Additionally, symmetries have a field corresponding to each possible vector written in Dynkin notation that uses only the characters <code>o</code> and <code>x</code>. For example <code>cd'bc3'.xoo</code> is a vector pointing toward the vertex of a cube or the face of an octahedron.</p>"},{"location":"hsc/lua/geometry/symmetry/#methods","title":"Methods","text":"<p>Symmetries have the following methods:</p> <ul> <li><code>:orbit()</code></li> <li><code>:vec()</code></li> <li><code>:thru()</code></li> </ul>"},{"location":"hsc/lua/geometry/symmetry/#symmetryorbit","title":"<code>symmetry:orbit()</code>","text":"<p><code>symmetry:orbit()</code> returns the orbit of its arguments under the symmetry. See <code>symmetry:orbit()</code> for more.</p>"},{"location":"hsc/lua/geometry/symmetry/#symmetryvec","title":"<code>symmetry:vec()</code>","text":"<p><code>symmetry:vec()</code> returns constructs a vector in the mirror basis, where each axis is parallel to all but one mirror. It can be called in either of two ways:</p> <ul> <li>Dynkin notation. Calling <code>:vec()</code> with a Dynkin notation string constructs the corresponding vector. See Dynkin notation for an explanation and examples.</li> <li>Vector. Calling <code>:vec()</code> with an existing vector converts it to the mirror basis. The first component of the input determines the distance from the first mirror; the second component of the input determines the distance from the second mirror; etc.</li> </ul>"},{"location":"hsc/lua/geometry/symmetry/#symmetrythru","title":"<code>symmetry:thru()</code>","text":"<p><code>symmetry:thru()</code> constructs a transformation by composing reflections across the corresponding mirror planes. Each mirror plane is specified as an index. First each reflection is constructed, and then they are composed in the order specified.</p> <p>For example, <code>symmetry:thru(1, 3, 2)</code> constructs a transformation that reflects through the second mirror plane, then the third, then the first. Note that the order seems backwards, because the transforms are composed in the order written.</p> Examples using symmetry:thru()<pre><code>cd'bc3':thru(2, 1) -- clockwise 90-degree rotation of a face of a cube\ncd'bc3':thru(3, 2) -- clockwise 120-degree rotation of a vertex of a cube\ncd'bc3':thru(3, 1) -- clockwise 180-degree rotation of an edge of a cube\n\nlocal sym = cd'bc3'\nlocal a = sym:thru(1, 2, 3)\nlocal b = sym:thru(1) * sym:thru(2) * sym:thru(3)\nassert(a == b)\n</code></pre>"},{"location":"hsc/lua/geometry/symmetry/#operations","title":"Operations","text":"<p>Symmetries support the following operations:</p> <ul> <li><code>type(symmetry)</code> returns <code>'symmetry'</code></li> <li><code>tostring(symmetry)</code></li> </ul>"},{"location":"hsc/lua/geometry/symmetry/#dynkin-notation","title":"Dynkin notation","text":"<p>To describe points relative to a symmetric mirror construction, we use Dynkin notation. A point specified in Dynkin notation consists of a string of characters, each specifying the distance from its corresponding mirror planes. Here is a list of all the symbols supported by Hyperspeedcube:</p> Symbol Distance <code>o</code> \\(0\\) <code>x</code> \\(1\\) <code>u</code> \\(2\\) <code>q</code> \\(\\sqrt 2\\) <code>f</code> \\(\\phi = \\frac{1 + \\sqrt 5}{2}\\) <p>For example, the string <code>oqx</code> describes a point touching the first mirror plane, \\(\\sqrt 2\\) units from the second mirror plane, and \\(\\phi\\) units from the third mirror plane.</p> Examples using Dynkin notation<pre><code>local sym = cd'h3' -- symmetry of a dodecahedron or icosahedron\nsym:orbit(sym.oox.unit) -- face poles of a dodecahedron, or vertices of an icosahedron\nsym:orbit(sym.oxo.unit) -- edge poles of a dodecahedron or icosahedron\nsym:orbit(sym.xoo.unit) -- vertices of a dodecahedron or face poles of an icosahedron\n\nlocal sym = cd'bc4' -- symmetry of a hypercube or 16-cell\nsym:orbit(sym.ooox.unit) -- cell poles of a hypercube, or vertices of a 16-cell\nsym:orbit(sym.ooxo.unit) -- face poles of a hypercube, or edge poles of a 16-cell\nsym:orbit(sym.oxoo.unit) -- edge poles of a hypercube, or face poles of a 16-cell\nsym:orbit(sym.xooo.unit) -- vertices of a hypercube, or cell poles of a 16-cell\n</code></pre> <ol> <li> <p>Derived from https://commons.wikimedia.org/wiki/File:Finite_coxeter.svg \u21a9</p> </li> <li> <p>Lua syntax allows omitting the parentheses when calling a function with a table literal or string literal as its only argument. For example, you can write <code>cd{4, 3}</code> instead of <code>cd({4, 3})</code> or <code>cd'bc3'</code> instead of <code>cd('bc3')</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/lua/geometry/transform/","title":"Transform","text":"<p>A transform is a combination of some sequence of translations, rotations, and reflections in space. Hyperspeedcube uses motors from the Projective Geometric Algebra, but knowledge of geometric algebra is not required in order to use the API effectively.</p> <p>The examples on this page assume 3D, but the same API works in other dimensions.</p>"},{"location":"hsc/lua/geometry/transform/#why-not-matrices","title":"Why not matrices?","text":"<p>Although transforms are commonly represented using matrices, motors provide a few advantages:</p> <ul> <li>Fewer numbers to store (below 6D)</li> <li>Good for interpolation</li> <li>Can distinguish between 180-degree rotations in opposite directions, which is good for displaying correct animations</li> </ul>"},{"location":"hsc/lua/geometry/transform/#constructors","title":"Constructors","text":"<p>All these constructors return a transform with the number of dimensions of the currently active space, and therefore can only be called in a context with a global number of dimensions (such as during the construction of a puzzle). They produce an error if it is called when there is not a global number of dimensions.</p>"},{"location":"hsc/lua/geometry/transform/#ident","title":"<code>ident()</code>","text":"<p><code>ident()</code> constructs the identity transformation. It takes no arguments.</p>"},{"location":"hsc/lua/geometry/transform/#refl","title":"<code>refl()</code>","text":"<p><code>refl()</code> constructs a transform representing a reflection or point reflection and can be called in any of several ways:</p> <ul> <li>No arguments. Calling <code>refl()</code> with no arguments constructs a point reflection across the origin.</li> <li>Point. Calling <code>refl()</code> with a point constructs a point reflection across that point. For example, <code>refl(point(0, -2))</code> constructs a point reflection across the point \\(\\langle 0, -2, 0 \\rangle\\).</li> <li>Vector. Calling <code>refl()</code> with a vector constructs a reflection through that vector. The magnitude of the vector is ignored. For example, <code>refl(point(0, -2))</code> constructs a reflection across the plane \\(y=0\\).</li> <li>Hyperplane. Calling <code>refl()</code> with a hyperplane constructs a reflection across that hyperplane. The orientation of the plane is ignored. For example, <code>refl(plane('z', 1/2))</code> constructs a reflection across the plane \\(z = 0.5\\).</li> </ul>"},{"location":"hsc/lua/geometry/transform/#rot","title":"<code>rot()</code>","text":"<p><code>rot()</code> constructs a transform representing a rotation fixing the origin and takes several named arguments as values in a table:</p> <ul> <li><code>from</code> is a vector. The magnitude of the vector is ignored.</li> <li><code>to</code> is the destination vector for <code>from</code> once the rotation has been applied. The magnitude of the vector is ignored.</li> <li><code>fix</code> is a blade to keep fixed during the rotation.</li> <li><code>angle</code> is the angle of the rotation in radians.</li> </ul> <p>Any combination of these may be specified, subject to the following constraints:</p> <ul> <li><code>from</code> and <code>to</code> are mutually dependent; i.e., one cannot be specified without the other.</li> <li>If <code>from</code> and <code>to</code> are not specified, then <code>fix</code> and <code>angle</code> are both required and <code>fix</code> must be dual to a 2D plane. (1)</li> <li><code>from</code> and <code>to</code> must not be opposite each other. (2)</li> </ul> <p>If <code>from</code> and <code>to</code> are specified, then the rotation is constructed using these steps:</p> <ol> <li>If <code>fix</code> is specified, then <code>from</code> and <code>to</code> are orthogonally rejected from <code>fix</code>. (3)</li> <li>If <code>angle</code> is specified, then <code>to</code> is minimally adjusted to have the angle <code>angle</code> with respect to <code>from</code>.</li> <li><code>from</code> and <code>to</code> are normalized.</li> <li>A rotation is constructed that takes <code>from</code> to <code>to</code> along the shortest path.</li> </ol> <p>If <code>from</code> and <code>to</code> are not specified, then a rotation of <code>angle</code> around <code>fix</code> is constructed. This method is not recommended because the direction of the rotation is unspecified and may change depending on the sign of <code>fix</code>.</p> <ol> <li>This is possible with antigrade 3 (if its bulk is zero) or antigrade 2 (if its bulk is nonzero). For example, in 3D, <code>fix</code> must be one of the following:<ul> <li>A vector (zero bulk, grade 1, antigrade 3)</li> <li>A line (nonzero bulk, grade 2, antigrade 2)</li> </ul> </li> <li>There are many 180-degree rotations that take any given vector to its opposite, so this case is disallowed due to ambiguity.</li> <li>This results in the component of each vector that is perpendicular to <code>fix</code>.</li> </ol> Examples of rotation construction<pre><code>-- 45-degree rotation in the XY plane\nrot{from = 'x', to = vec(1, 1, 0)}\n\n-- 180-degree rotation around the Z axis\nrot{fix = 'z', angle = pi}\n\n-- Jumbling rotation of the Curvy Copter puzzle\nrot{fix = vec(1, 1, 0), angle = acos(1/3)}\n\n-- 90-degree rotation around an edge of a cube\nrot{fix = vec(1, 1, 0), from = 'x', to = 'z'}\n</code></pre>"},{"location":"hsc/lua/geometry/transform/#fields","title":"Fields","text":"<p>Transforms have the following fields:</p> <ul> <li><code>.ndim</code> is the number of dimensions of the space containing the transform</li> <li><code>.is_ident</code> is <code>true</code> if the transform is equivalent to the identity transform, or <code>false</code> otherwise</li> <li><code>.is_refl</code> is <code>true</code> if the transform is equivalent to an odd number of reflections, or <code>false</code> otherwise<sup>1</sup></li> <li><code>.rev</code> is the reverse transform</li> </ul>"},{"location":"hsc/lua/geometry/transform/#methods","title":"Methods","text":"<p>Transforms have the following method:</p> <ul> <li><code>:transform(object)</code> returns the object transformed according to the transform</li> <li><code>:transform_oriented(transform2)</code> returns <code>transform2</code> transformed according to the transform, but reversed it if it was mirrored</li> </ul> <p>Below is a list of all types that can be transformed:</p> <ul> <li>Blades, including vectors and points</li> <li>Hyperplanes</li> <li>Regions</li> <li>Other transforms</li> <li>Axes</li> <li>Colors</li> <li>Twists</li> </ul>"},{"location":"hsc/lua/geometry/transform/#operations","title":"Operations","text":"<p>Transforms support the following operations:</p> <ul> <li><code>transform * transform</code> (composition of transforms)</li> <li><code>transform ^ int</code> (integer power of transform)</li> <li><code>transform == transform</code> (uses approximate floating-point comparison)</li> <li><code>transform ~= transform</code> (uses approximate floating-point comparison)</li> <li><code>type(transform)</code> returns <code>'transform'</code></li> <li><code>tostring(transform)</code></li> </ul> <ol> <li> <p>Note that in an even number of dimensions (2D, 4D, etc.) a point reflection contains an even number of reflections, so <code>refl().is_refl</code> is <code>false</code> in those dimensions.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/lua/puzzle-construction/axes/","title":"Axes","text":""},{"location":"hsc/lua/puzzle-construction/axes/#axis-system","title":"Axis system","text":"<p>The axis system is an ordered list of twist axes. It can be accessed during puzzle construction as <code>puzzle.axes</code>.</p> <p>Axes can be added to the axis system using <code>puzzle.axes:add()</code>.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#axis-indexing","title":"Axis indexing","text":"<p>The axis system can be indexed by the name or index of a axis, or by its vector.</p> Examples of axis indexing<pre><code>-- Gets the axis with the name \"L\"\npuzzle.axes.L\n\n-- Gets the first axis in the list\npuzzle.axes[1]\n\n-- Gets the axis with the vector (1,0,0)\npuzzle.axes[vec('x')]\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/axes/#fields","title":"Fields","text":"<p>The axis system has no fields.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#methods","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/axes/#puzzleaxesadd","title":"<code>puzzle.axes:add()</code>","text":"<p><code>puzzle.axes:add()</code> adds a twist axis to the axis system, optionally adding layers to it and slicing the puzzle on each layer boundary. It takes two arguments: a vector for the new twist axis, and an optional table containing additional arguments. The new axis is returned.</p> <p>If the vector is an orbit of vectors instead of just a single one, then <code>puzzle.axes:add()</code> will add an axis for each vector, all with the same layers. If the orbit has names assigned, then the new axes created by the cut will be assigned those names. An orbit of the new axes is returned.</p> <p>The table may contain two optional keys:</p> <ul> <li><code>layers</code> is an optional sequential table of distances from the origin at which to add layer boundaries</li> <li><code>slice</code> is an optional boolean which defaults to <code>true</code></li> </ul> <p>If the table contains a sequence, then that sequence is used in place of <code>layers</code>. In this case the <code>slice</code> key is still used as normal.</p> <p>If <code>layers</code> is specified, then <code>add_axes()</code> will automatically add layers to each axis it creates.</p> <p>If <code>slice</code> is <code>true</code>, then <code>add_axes()</code> will automatically slice all pieces at the layer boundaries specified by <code>layers</code>.</p> Examples using puzzle.axes:add()<pre><code>local sym = cd'bc3'\n\n-- Add cubic axes with no layers\npuzzle.axes:add(sym:orbit(sym.oox.unit))\n\n-- Add cubic axes with a single cut through the origin\npuzzle.axes:add(sym:orbit(sym.oox.unit), {0})\n\n-- Add cubic axes with 3x3x3-like cuts\npuzzle.axes:add(sym:orbit(sym.oox.unit), {1/3})\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/axes/#puzzleaxesautoname","title":"<code>puzzle.axes:autoname()</code>","text":"<p><code>puzzle.axes:autoname()</code> assigns alphabetic names to all twist axes. It takes no arguments.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#puzzleaxesrename","title":"<code>puzzle.axes:rename()</code>","text":"<p><code>puzzle.axes:rename()</code> renames multiple axes at once. See <code>:rename()</code></p>"},{"location":"hsc/lua/puzzle-construction/axes/#puzzleaxesswap","title":"<code>puzzle.axes:swap()</code>","text":"<p><code>puzzle.axes:swap()</code> swaps two axes in the ordering. See <code>:swap()</code></p>"},{"location":"hsc/lua/puzzle-construction/axes/#puzzleaxesreorder","title":"<code>puzzle.axes:reorder()</code>","text":"<p><code>puzzle.axes:reorder()</code> changes the ordering of all axes. See <code>:reorder()</code></p>"},{"location":"hsc/lua/puzzle-construction/axes/#operations","title":"Operations","text":"<ul> <li><code>#puzzle.axes</code> returns the number of axes that have been defined</li> <li><code>type(puzzle.axes)</code> returns <code>'axissystem'</code></li> <li><code>tostring(puzzle.axes)</code></li> <li><code>ipairs(puzzle.axes)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/axes/#axis","title":"Axis","text":"<p>An axis is a twist axis around which twists can be defined.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#fields_1","title":"Fields","text":"<ul> <li><code>.name</code> is the string name of the color</li> <li><code>.index</code> is the integer index of the color in the color system</li> <li><code>.vector</code> is the vector of the axis, which typically stays fixed during any of its twists</li> <li><code>.layers</code> is the layer system of the axis</li> <li><code>.opposite</code> is the axis with the opposite vector, or <code>nil</code> if there is none</li> </ul> <p>Some fields can be written to:</p> <ul> <li>Writing a new string to <code>.name</code> renames the axis</li> <li>Writing to <code>.index</code> reorders the axis to that index, shifting the axes in between</li> </ul> <p>All other fields are read-only.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#methods_1","title":"Methods","text":"<p>Axes have no methods.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#operations_1","title":"Operations","text":"<ul> <li><code>axis == axis</code></li> <li><code>axis ~= axis</code></li> <li><code>type(axis)</code> returns <code>'axis'</code></li> <li><code>tostring(axis)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/axes/#layer-system","title":"Layer system","text":"<p>A layer system is an ordered list of the layers on an axis. It can be accessed during puzzle construction as <code>axis.layers</code>.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#layer-system-indexing","title":"Layer system indexing","text":"<p>Indexing a layer system by a layer index returns a table with the following keys:</p> <ul> <li><code>bottom</code> is the hyperplane bounding the bottom of the layer</li> <li><code>top</code> is the hyperplane bounding the top of the layer, or <code>nil</code> if there is none</li> </ul>"},{"location":"hsc/lua/puzzle-construction/axes/#fields_2","title":"Fields","text":"<p>A layer system has no fields.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#methods_2","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/axes/#axislayersadd","title":"<code>axis.layers:add()</code>","text":"<p><code>axis.layers:add()</code> adds a new layer to the layer system. It takes two arguments: a hyperplane bounding the bottom of the layer, and an optional hyperplane bounding the top of the layer. If the second hyperplane is omitted, then the layer is unbounded.</p>"},{"location":"hsc/lua/puzzle-construction/axes/#operations_2","title":"Operations","text":"<ul> <li><code>#axis.layers</code> returns the number of layers in the layer system</li> <li><code>type(axis.layers)</code> returns <code>'layersystem'</code></li> <li><code>ipairs(axis.layers)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/axes/#layer","title":"Layer","text":"<p>A layer is a region along a twist axis where pieces may be affected by a twist. It is bounded below by a hyperplane, and optionally bounded above by another hyperplane.</p>"},{"location":"hsc/lua/puzzle-construction/colors/","title":"Colors","text":""},{"location":"hsc/lua/puzzle-construction/colors/#color-system","title":"Color system","text":"<p>The color system is an ordered list of sticker colors. It can be accessed during puzzle construction as <code>puzzle.colors</code>.</p> <p>Colors can be added to the color system explicitly using <code>puzzle.colors:add()</code> or implicitly using <code>puzzle:carve()</code>.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#color-indexing","title":"Color indexing","text":"<p>The color system can be indexed by the name or index of a color, or by any of its hyperplanes.</p> Examples of color indexing<pre><code>-- Gets the color with the name \"L\"\npuzzle.colors.L\n\n-- Gets the first color in the list\npuzzle.colors[1]\n\n-- Gets the color with the plane X=1 (oriented outward)\npuzzle.colors[plane('x')]\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/colors/#fields","title":"Fields","text":"<p>The color system has no fields.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#methods","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/colors/#puzzlecolorsadd","title":"<code>puzzle.colors:add()</code>","text":"<p><code>puzzle.colors:add()</code> adds a color to the color system. It takes a single argument: a string (which will be the name of the color), or a table with data about the color.</p> <p>The table has the following keys:</p> <ul> <li><code>name</code> is an optional string, and will be the name of the color</li> <li><code>display</code> is an optional string, and will be the display name of the color</li> <li><code>default</code> is an optional string, and will be the default for the color</li> </ul> <p>Names should be short (typically 1-3 uppercase letters), but display names can be longer.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#puzzlecolorsset_defaults","title":"<code>puzzle.colors:set_defaults()</code>","text":"<p><code>puzzle.colors:set_defaults()</code> sets multiple default colors at once. It takes a mapping from colors to strings (the new default colors).</p>"},{"location":"hsc/lua/puzzle-construction/colors/#puzzlecolorsrename","title":"<code>puzzle.colors:rename()</code>","text":"<p><code>puzzle.colors:rename()</code> renames multiple colors at once. See <code>:rename()</code></p>"},{"location":"hsc/lua/puzzle-construction/colors/#puzzlecolorsswap","title":"<code>puzzle.colors:swap()</code>","text":"<p><code>puzzle.colors:swap()</code> swaps two colors in the ordering. See <code>:swap()</code></p>"},{"location":"hsc/lua/puzzle-construction/colors/#puzzlecolorsreorder","title":"<code>puzzle.colors:reorder()</code>","text":"<p><code>puzzle.colors:reorder()</code> changes the ordering of all colors. See <code>:reorder()</code></p>"},{"location":"hsc/lua/puzzle-construction/colors/#operations","title":"Operations","text":"<ul> <li><code>#puzzle.colors</code> returns the number of colors that have been defined</li> <li><code>type(puzzle.colors)</code> returns <code>'colorsystem'</code></li> <li><code>tostring(puzzle.colors)</code></li> <li><code>ipairs(puzzle.colors)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/colors/#color","title":"Color","text":"<p>A color is a color that can be assigned to a sticker. Each color has a list of \"surfaces,\" which are hyperplanes where stickers typically have that color (although they are not required to).</p> <p>When required as input to a function, a color may be specified as a color object, a color index (integer), or a color name (string).</p> <p>Each color has a default color, which is a string used to look up the user's preferences for a color. For example, the default color may be <code>'red'</code>, which would default to the user's prefered color named <code>red</code>.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#fields_1","title":"Fields","text":"<p>Colors have the following fields:</p> <ul> <li><code>.name</code> is the string name of the color</li> <li><code>.display</code> is the string name of the color</li> <li><code>.index</code> is the integer index of the color in the color system</li> <li><code>.default</code> is the string used to look up the default value for the color</li> </ul> <p>Some fields can be written to:</p> <ul> <li>Writing a new string to <code>.name</code> renames the color</li> <li>Writing a new string to <code>.display</code> changes the display name</li> <li>Writing to <code>.index</code> reorders the color to that index, shifting the colors in between</li> <li>Writing a new string to <code>.default</code> changes the default color</li> </ul> <p>All other fields are read-only.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#methods_1","title":"Methods","text":"<p>Colors have no methods.</p>"},{"location":"hsc/lua/puzzle-construction/colors/#operations_1","title":"Operations","text":"<ul> <li><code>color == color</code></li> <li><code>color ~= color</code></li> <li><code>type(color)</code> returns <code>'color'</code></li> <li><code>tostring(color)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/puzzle/","title":"Puzzle","text":"<p>When defining a puzzle, the <code>build</code> function takes a single argument of type <code>puzzle</code>. The puzzle is initialized with a single infinite piece; this piece must be <code>carve()</code>ed to make it finite in order to have a valid puzzle. It can then have twist axes and twists defined.</p>"},{"location":"hsc/lua/puzzle-construction/puzzle/#fields","title":"Fields","text":"<p>Puzzles have the following fields:</p> <ul> <li><code>.id</code> is the unique ID of the puzzle</li> <li><code>.space</code> is the space in which the puzzle is being constructed</li> <li><code>.ndim</code> is the number of dimensions of the space in which the puzzle is being constructed</li> <li><code>.colors</code> is the color system of the puzzle</li> <li><code>.axes</code> is the axis system of the puzzle</li> <li><code>.twists</code> is the twist system of the puzzle</li> </ul>"},{"location":"hsc/lua/puzzle-construction/puzzle/#methods","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/puzzle/#puzzlecarve","title":"<code>puzzle:carve()</code>","text":"<p><code>puzzle:carve()</code> cuts all pieces in the puzzle and discards pieces that are \"outside\" the cut. It takes two arguments: the plane along which to cut, and an optional table containing additional arguments.</p> <p>The orientation of the cutting plane determines which pieces are kept or discarded; the normal vector of the plane points toward pieces that will be discarded.</p> <p>If the cutting plane is an orbit of planes instead of just a single one, then <code>puzzle:carve()</code> will perform a cut for each plane in the orbit. If the orbit has names assigned, then the new colors created by the cut will be assigned those names.</p> <p>The table may contain one optional key:</p> <ul> <li><code>stickers</code> is an optional value which defaults to <code>true</code></li> </ul> <p>If <code>stickers</code> is <code>nil</code> or <code>true</code>, then <code>carve()</code> will add a new color for each cut and create stickers along the cut; if <code>stickers</code> is <code>false</code>, then <code>carve()</code> will leave the peices unstickered.</p> <p>If <code>stickers</code> is color or a string containing the name of a color, <code>carve()</code> will create stickers along the cut and assign that color to them.</p> <p>If <code>stickers</code> is a table, then each key is a string containing the name of an element in the orbit and each value is the color to assign to the stickers along the cut. If the table is missing a key, then no stickers are created.</p> <p>A color may be specified as a color value or as a string containing the name of a color. If there is no color with the given name, then one will be created.</p> <p>Unstickered pieces</p> <p>If a piece is visible from the outside of the puzzle, it should be stickered, using an extra color if necessary.</p> <p>Some puzzles with real-world designs leave faces of pieces unstickered; this is not advised in Hyperspeedcube. It is much better to sticker them using an extra color, and let the user hide them if they would like to.</p> Examples using puzzle:carve()<pre><code>local sym = cd'bc3'\n\n-- Carve at X=1, deleting everything with X&gt;1\npuzzle:carve(plane('x'))\n\n-- Carve at X=1, deleting everything with X&lt;1\npuzzle:carve(-plane('x'))\n\n-- Carve a cube\npuzzle:carve(sym:orbit(sym.oox.unit))\n\n-- Carve an unstickered octahedron\npuzzle:carve(sym:orbit(sym.xoo.unit), {stickers=false})\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/puzzle/#puzzleslice","title":"<code>puzzle:slice()</code>","text":"<p><code>puzzle:slice()</code> cuts all pieces in the puzzle. It takes one argument: the plane along which to cut.</p> <p>The orientation of the cutting plane is ignored.</p> <p>If the cutting plane is an orbit of planes instead of just a single one, then <code>puzzle:carve()</code> will perform a cut for each plane in the orbit.</p> Examples using puzzle:slice()<pre><code>local sym = cd'bc3'\n\n-- Slice at X=1, keeping all resulting pieces\npuzzle:slice(plane('x'))\n\npuzzle:slice(sym:orbit('x'))\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/puzzle/#puzzleadd_piece_type","title":"<code>puzzle:add_piece_type()</code>","text":"<p><code>puzzle:add_piece_type()</code> adds a piece type if it does not already exist, and sets it display name. It takes one argument: a table containing the following keys:</p> <ul> <li><code>name</code> is a string containing a name for the piece type (e.g., <code>center/t_2</code>)</li> <li><code>display</code> is a string containing a user-facing display name for the piece type (e.g., <code>T-center (2)</code>)</li> </ul> <p>The key <code>name</code> is required. <code>display</code> is optional.</p> <p><code>name</code> consists of segments separated by <code>/</code>, which describes its position in the hierarchy of piece types. Parent piece types are automatically created; for example, <code>puzzle:add_piece_type{ name = 'a/b/c' }</code> will create the piece types <code>a</code>, <code>a/b</code>, and <code>a/b/c</code> if they do not already exist. Only the leaf piece (<code>a/b/c</code> in the example) will have its display name set.</p> <p>Tip</p> <p>When <code>name</code> and <code>display</code> are both format strings derived from the same parameters, use <code>string.fmt2</code> for conciseness.</p> Example using `string.fmt2()`<pre><code>for i = 1, size do\n  local name, display = string.fmt2('center/x_%d', \"X-center (%d)\", i)\n  puzzle:mark_piece{ region = ..., name = name, display = display }\nend\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/puzzle/#puzzlemark_piece","title":"<code>puzzle:mark_piece()</code>","text":"<p><code>puzzle:mark_piece()</code> marks the piece type of a piece. It takes one argument: a table containing the following keys:</p> <ul> <li><code>region</code> is a region containing a piece</li> <li><code>name</code> is a string containing a name for the piece type (e.g., <code>center/t_2</code>)</li> <li><code>display</code> is a string containing a user-facing display name for the piece type (e.g., <code>T-center (2)</code>)</li> </ul> <p>The keys <code>region</code> and <code>name</code> are required. <code>display</code> is optional.</p> <p><code>puzzle:mark_piece()</code> automatically calls <code>puzzle:add_piece_type()</code> to ensure that the piece type exists and to assign a display name if one is provided.</p> <p>If <code>region</code> matches more or fewer than 1 piece, then a warning is emitted.</p> <p>Note that a piece cannot be marked with a parent type. For example, if the piece type <code>a/b/c</code> exists, then no piece may be marked with <code>a/b</code> or <code>a</code>.</p>"},{"location":"hsc/lua/puzzle-construction/puzzle/#puzzleunify_piece_types","title":"<code>puzzle:unify_piece_types()</code>","text":"<p><code>puzzle:unify_piece_types()</code> marks the piece type for many pieces using symmetry. It takes one argument: the symmetry by which to expand.</p> Example defining piece types<pre><code>-- Define piece types for a 3x3x3 Rubik's cube\npuzzle:mark_piece{\n  region = R(2) &amp; U(2) &amp; F(1),\n  name = 'center',\n  display = \"Center\",\n}\npuzzle:add_piece_type{\n  name = 'moving',\n  display = \"Moving pieces\",\n}\npuzzle:mark_piece{\n  region = R(2) &amp; U(1) &amp; F(1),\n  name = 'moving/edge',\n  display = \"Edge\",\n}\npuzzle:mark_piece{\n  region = R(1) &amp; U(1) &amp; F(1),\n  name = 'moving/corner',\n  name = \"Corner\",\n}\npuzzle:unify_piece_types(sym'bc3')\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/puzzle/#operations","title":"Operations","text":"<p>Puzzles support the following operations:</p> <ul> <li><code>type(puzzle)</code> returns <code>'puzzle'</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/twists/","title":"Twists","text":""},{"location":"hsc/lua/puzzle-construction/twists/#twist-system","title":"Twist system","text":"<p>The twist system is a list of twists, sorted in alphabetical order by name. It can be accessed during puzzle construction as <code>puzzle.twists</code>.</p> <p>Twists can be added to the twist system using <code>puzzle.twists:add()</code>.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#twist-indexing","title":"Twist indexing","text":"<p>The twist system can be indexed by the name or index of a twist.</p> Examples of twist indexing<pre><code>-- Gets the twist with the name \"L\"\npuzzle.twists.L\n\n-- Gets the twist with the name \"L'\"\npuzzle.twists[\"L'\"]\n\n-- Gets the first twist alphabetically\npuzzle.twists[1]\n</code></pre>"},{"location":"hsc/lua/puzzle-construction/twists/#fields","title":"Fields","text":"<p>The twist system has no fields.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#methods","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/twists/#puzzletwistsadd","title":"<code>puzzle.twists:add()</code>","text":"<p><code>puzzle.twists:add()</code> adds a twist to the twist system, along with (optionally) its inverses and multipliers. It takes three arguments: an axis whose layers bound the pieces affected by the twist, a transform to apply to pieces, and an optional table with extra data about the twist.</p> <p>The table has the following keys:</p> Key Type Default value Description <code>multipliers</code> <code>boolean</code> See note 1 whether to generate double/triple/etc. twists<sup>1</sup> <code>inverse</code> <code>boolean</code> See note 1 whether to generate inverse twist<sup>2</sup> <code>prefix</code> <code>string</code> axis name prefix before twist name <code>name</code> <code>string</code> <code>nil</code> name for twist <code>suffix</code> <code>string</code> <code>nil</code> suffix after twist name <code>inv_name</code> <code>string</code> <code>nil</code> name for inverse twist <code>inv_suffix</code> <code>string</code> See note 2 suffix after inverse twist name <code>name_fn</code> <code>function</code> <code>nil</code> function from integer to string <code>qtm</code> <code>integer</code> <code>1</code> value of the twist in the quantum turn metric <code>gizmo_pole_distance</code> <code>number</code> <code>nil</code> distance of the gizmo pole facet <p>Notes</p> <ol> <li><code>true</code> in 3D; <code>false</code> in 4D+</li> <li>If <code>inv_name</code> is <code>nil</code> or unspecified, then <code>inv_suffix</code> defaults to <code>\"'\"</code> (a string containing the <code>'</code> character); if <code>inv_name</code> is non-<code>nil</code>, then <code>inv_suffix</code> defaults to an empty string</li> </ol> <p>If <code>name_fn</code> is non-<code>nil</code>, then <code>name</code> and <code>inv_name</code> must both be <code>nil</code>.</p> <p><code>name_fn</code> takes a single argument: an integer corresponding to the twist multiplier (e.g., <code>1</code> for <code>R</code>, <code>-1</code> for <code>R'</code>, <code>2</code> for <code>R2</code>, <code>-2</code> for <code>R2'</code>, etc.). It returns a string, which is used in place of both <code>name</code> and <code>inv_name</code>.</p> <p>Each twist is assigned a name by concatenating <code>&lt;prefix&gt; .. &lt;name&gt; .. &lt;suffix&gt; .. &lt;multiplier&gt;</code>, where: - <code>&lt;prefix&gt;</code> is <code>prefix</code> - <code>&lt;name&gt;</code> is either the output of <code>name_fn</code> (if <code>name_fn</code> is non-<code>nil</code>) or <code>name</code>/<code>inv_name</code> (selected using the sign of the multiplier). - <code>&lt;suffix&gt;</code> is <code>suffix</code>/<code>inv_suffix</code> (selected using the sign of the multiplier) - <code>&lt;multiplier&gt;</code> is <code>tostring(multiplier)</code></p>"},{"location":"hsc/lua/puzzle-construction/twists/#puzzletwistsrename","title":"<code>puzzle.twists:rename()</code>","text":"<p><code>puzzle.twists:rename()</code> renames multiple twists at once. See <code>:rename()</code></p>"},{"location":"hsc/lua/puzzle-construction/twists/#operations","title":"Operations","text":"<ul> <li><code>#puzzle.twists</code> returns the number of twists that have been defined</li> <li><code>type(puzzle.twists)</code> returns <code>'twistsystem'</code></li> <li><code>tostring(puzzle.twists)</code></li> <li><code>ipairs(puzzle.twists)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/twists/#twist","title":"Twist","text":"<p>A twist is a twist that can be applied to the puzzle.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#fields_1","title":"Fields","text":"<ul> <li><code>.name</code> is the string name of the color</li> <li><code>.axis</code> is the axis of the twist, which is typically fixed by its transform</li> <li><code>.transform</code> is the transform applied to pieces during the twist</li> </ul> <p>Some fields can be written to:</p> <ul> <li>Writing a new string to <code>.name</code> renames the twist</li> </ul> <p>All other fields are read-only.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#methods_1","title":"Methods","text":"<p>Axes have no methods.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#operations_1","title":"Operations","text":"<ul> <li><code>twist == twist</code></li> <li><code>twist ~= twist</code></li> <li><code>twist * twist</code> composes two twists, if there is a twist corresponding to their composition</li> <li><code>twist ^ number</code> returns the twist composed with itself some number of times (which may be negative), if there is such a twist</li> <li><code>type(twist)</code> returns <code>'twist'</code></li> <li><code>tostring(twist)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/twists/#layer-system","title":"Layer system","text":"<p>A layer system is an ordered list of the layers on an axis. It can be accessed during puzzle construction as <code>axis.layers</code>.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#layer-system-indexing","title":"Layer system indexing","text":"<p>Indexing a layer system by a layer index returns a table with the following keys:</p> <ul> <li><code>bottom</code> is the hyperplane bounding the bottom of the layer</li> <li><code>top</code> is the hyperplane bounding the top of the layer, or <code>nil</code> if there is none</li> </ul>"},{"location":"hsc/lua/puzzle-construction/twists/#fields_2","title":"Fields","text":"<p>A layer system has no fields.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#methods_2","title":"Methods","text":""},{"location":"hsc/lua/puzzle-construction/twists/#axislayersadd","title":"<code>axis.layers:add()</code>","text":"<p><code>axis.layers:add()</code> adds a new layer to the layer system. It takes two arguments: a hyperplane bounding the bottom of the layer, and an optional hyperplane bounding the top of the layer. If the second hyperplane is omitted, then the layer is unbounded.</p>"},{"location":"hsc/lua/puzzle-construction/twists/#operations_2","title":"Operations","text":"<ul> <li><code>#axis.layers</code> returns the number of layers in the layer system</li> <li><code>type(axis.layers)</code> returns <code>'layersystem'</code></li> <li><code>ipairs(axis.layers)</code></li> </ul>"},{"location":"hsc/lua/puzzle-construction/twists/#layer","title":"Layer","text":"<p>A layer is a region along a twist axis where pieces may be affected by a twist. It is bounded below by a hyperplane, and optionally bounded above by another hyperplane.</p> <ol> <li> <p>E.g., <code>R2</code> from <code>R</code> \u21a9</p> </li> <li> <p>E.g., <code>R'</code> from <code>R</code> \u21a9</p> </li> </ol>"},{"location":"hsc/puzzle-dev/","title":"Puzzle Development","text":"<p>The goal of this tutorial series is to teach how to develop puzzles for Hyperspeedcube 2.</p> <p>This series is meant to be read in order; if you don't understand something, try rereading earlier pages until they make sense. If it still doesn't make sense after rereading, ping me (@HactarCE or @Hyperspeedcube Developer) on the Hypercubers Discord server.</p> <p>Read Prequisites first to make sure you have the prerequisite knowledge.</p>"},{"location":"hsc/puzzle-dev/first-puzzle/","title":"First Puzzle","text":"<p>Now that we know all the puzzle jargon, let's build a shallow-cut face-turning cube (that's the standard 3x3x3 Rubik's cube) in Hyperspeedcube. First I'll show you the code and then we'll dissect each part.</p> 3x3x3.lua<pre><code>puzzles:add('3x3x3', {\n  name = \"3x3x3\",\n  ndim = 3,\n  build = function(self)\n    local sym = cd'bc3'\n\n    -- Carve the base shape\n    for _, v in sym:orbit(sym.oox.unit) do\n      self:carve(plane(v))\n    end\n\n    -- Add twist axes and slice puzzle\n    for _, v in sym:orbit(sym.oox.unit) do\n      self.axes:add(v, {1/3, -1/3})\n    end\n\n    -- Add twists\n    for _, axis in ipairs(self.axes) do\n      self.twists:add(axis, rot{fix = axis.vector, angle = tau/4})\n    end\n  end,\n})\n</code></pre>"},{"location":"hsc/puzzle-dev/first-puzzle/#boilerplate","title":"Boilerplate","text":"<p>I've tried my best to minimize the amount of boilerplate required to define a puzzle, but there's still some.</p> Boilerplate<pre><code>puzzles:add('3x3x3', {\n  name = \"3x3x3\",\n  ndim = 3,\n  build = function(self)\n    ...\n  end,\n})\n</code></pre> <p>The first string is the puzzle ID. This should have only letters, numbers, and underscores.</p> <p>The next string is the puzzle name. In this case, it's the same as the puzzle ID, but it isn't always. For a puzzle like Eitan's Star, the name should be <code>\"Eitan's Star\"</code> but the ID would have to be <code>'eitans_star'</code> since it can't contain spaces or apostrophes.</p> <p>Why the inconsistent quotation marks?</p> <p>Lua doesn't actually care whether you use single quotes <code>'like this'</code> or double quotes <code>\"like this\"</code>, except that you can only put literal quotes inside a string with the opposite quotation type, <code>'like \"this\"'</code> or <code>\"like 'this'\"</code>. I like to use single quotes for non-user-facing strings, like the puzzle ID (since single quotes are slightly easier to type), and double quotes for user-facing strings (because they might contain apostrophes). Plus it gives a hint to anyone reading the code about the semantics of the string: is it user-facing, or just a string ID for use within code?</p> <p>Then we have the number of dimensions, which should be pretty self-explanatory.</p> <p>Lastly, we have the <code>build</code> function, which runs when our puzzle is constructed. It takes a single argument, the <code>puzzle</code>, which we call <code>p</code>.</p>"},{"location":"hsc/puzzle-dev/first-puzzle/#symmetry","title":"Symmetry","text":""},{"location":"hsc/puzzle-dev/first-puzzle/#carving-the-base-shape","title":"Carving the base shape","text":"<p>At the beginning of the <code>build</code> function, our puzzle has a single piece that takes up all of 3D space.<sup>1</sup> Think of it like a really big block of marble that we can <code>carve()</code> our shape from.</p> <p>We could carve out each face individually ...</p> Please don't do this<pre><code>self:carve(vec(1, 0, 0))\nself:carve(vec(-1, 0, 0))\nself:carve(vec(0, 1, 0))\nself:carve(vec(0, -1, 0))\nself:carve(vec(0, 0, 1))\nself:carve(vec(0, 0, -1))\n</code></pre> <p>But since the puzzle is symmetric, we can use symmtery to simplify this. By starting with one face and iterating over its orbit, we can generate the other five.</p> <p>We start by generating the group \\(BC_3\\) (which you may recognize from the last section as the symmetry group of a cube) using the global <code>cd()</code> constructor.</p> Carving a cube using a loop<pre><code>local sym = cd'bc3'\n\nfor _, v in sym:orbit\n</code></pre>"},{"location":"hsc/puzzle-dev/first-puzzle/#adding-axes","title":"Adding axes","text":""},{"location":"hsc/puzzle-dev/first-puzzle/#adding-twists","title":"Adding twists","text":"<ol> <li> <p>Ok technically it's just a very large primordial cube that takes up a lot of 3D space, not all of it. The current iteration of the shape-cutting algorithm only knows how to handle finite shapes.\u00a0\u21a9</p> </li> </ol>"},{"location":"hsc/puzzle-dev/geometry/","title":"Puzzle Geometry","text":"<p>In order to build a puzzle in Hyperspeedcube, first you must understand the geometry of the puzzle. Fundamentally, we build puzzles by starting with a base shape, slicing it, and then defining how to transform pieces during twists. We have shorthand words for common ways to do this; for example:</p> <ul> <li>The 3<sup>3</sup> puzzle is a shallow-cut face-turning cube.</li> <li>The 2<sup>3</sup> puzzle is a half-cut face-turning cube.</li> <li>The Skewb is a half-cut vertex-turning cube.</li> <li>The Halpern-Maier Tetrahedron is either a deep-cut vertex-turning tetrahedron or a shallow-cut face-turning tetrahedron.</li> <li>The Megaminx is a shallow-cut face-turning dodecahedron.</li> <li>The Square-1 is a cube shapemod of a bandaged 3-layer half-cut 12-gonal prism.</li> <li>The Curvy Copter and Helicopter Cube are both shallow-cut edge-turning cubes.</li> <li>The Pentultimate is a half-cut face-turning dodecahedron.</li> <li>The face-turning octahedron is \u2014 you guessed it! \u2014 a face-turning octahedron.</li> </ul> <p>What do these terms mean? Let's start with the \"X-turning\" terms:</p> <ul> <li>face-turning means that the cuts are parallel to the face planes, and the twists rotate pieces in the plane of the face.</li> <li>vertex-turning means that cuts correspond to vertices of the shape, and the twists rotate pieces around vertices.</li> </ul> <p>You may also see edge-turning, facet-turning, and ridge-turning. (We prefer the terms \"facet\" and \"ridge\" in 4D, since \"face\" is used ambiguously in hypercubing.)</p> <ul> <li>shallow-cut means that the cuts are close to the outside of the polytope, and making them closer to the outside doesn't change the puzzle.</li> <li>half-cut means that the cuts pass through the center of the puzzle.</li> <li>cut-to-adjacent means that the cuts pass through the adjacent axes.</li> <li>deeper-cut-than-adjacent means that the cuts are deeper than the adjacent turning axes.</li> <li>deep-cut is somewhat vague and has a few different definitions depending on who you ask; in this guide, we'll use it to mean \"deeper than shallow-cut, and not better described by one of the other terms.\"</li> </ul>"},{"location":"hsc/puzzle-dev/geometry/#point-groups","title":"Point groups","text":"<p>Group theory is tremendously useful for writing puzzle definitions. Here's a quick crash course on point groups, which are the main kind of group we care about:</p> <p>A point group is a set of transformations of space that keep the origin fixed (i.e., rotations, reflections, and combinations of those). Each transformation is an element of the group. We can compose two elements by doing one transformation after the other, which produces another element in the set. Each element has an inverse, which is just the reverse transformation. Lastly, there's an identity element, which is the transformation that keeps everything where it is.</p> <p>The point groups used in puzzle definitions will be finite, and we'll construct them by describing their generators, which are a handful of elements that can be combined and inverted to get every element of the group. We say that the generators generate the group.</p>"},{"location":"hsc/puzzle-dev/geometry/#coxeter-groups","title":"Coxeter groups","text":"<p>Shapes can be described with names, like \"cube\" or \"dodecahedron\" or \"12-gonal prism.\" The most important property of a shape is its symmetry group, which is all the ways it can be rotated &amp; reflected and still look the same. The symmetries of most shapes we care about are a special kind of point group called a Coxeter group, which are written using Coxeter-Dynkin diagrams.</p> <p>A Coxeter group is generated by a handful of reflections. We can describe Coxeter groups using diagrams like these:</p> <p></p> <p>In each diagram, a node (one of the dots) corresponds to a reflection. Think of each node as representing a (hyper)plane, and the reflection across it. For any pair of dots:</p> <ul> <li>If there's no line directly connecting them, then their mirrors have a \\(\\frac{\\pi}{2}\\) angle between them (i.e., they are orthogonal)</li> <li>If there's a line directly connecting them with no label, then their mirrors have a \\(\\frac{\\pi}{3}\\) angle between them</li> <li>If there's a line directly connecting them labeled with a number \\(n\\), then their mirrors have a \\(\\frac{\\pi}{n}\\) angle between them</li> </ul> <p>Mirror convention</p> <p>It doesn't actually matter where the mirrors are in space, but there's a convention:</p> <ul> <li>The first mirror plane is perpendicular to the X axis</li> <li>The second mirror plane is perpendicular to some vector in the XY plane</li> <li>The third mirror plane is perpendicular to some vector in the XYZ subspace</li> <li>etc.</li> </ul> <p>This ensures that a Coxeter group generated from \\(n\\) mirrors always fits within \\(n\\)-dimensional space.</p> <p>To understand how this lets us generate shapes, I highly recommend reading the section titled Symmetries of the cube in the excellent article Building 4D polytopes by Mikael Hvidtfeldt Christensen.</p> <p>TODO: how to introduce face poles and Dynkin vector notation (<code>oox</code>/<code>xoo</code>/etc.)?</p>"},{"location":"hsc/puzzle-dev/geometry/#everything-below-this-line-needs-to-be-revisited","title":"EVERYTHING BELOW THIS LINE NEEDS TO BE REVISITED","text":"<p>Most of the Coxeter diagrams we use in puzzle construction are linear (i.e., the diagram has no branching), so we can write them using Schl\u00e4fli symbols.</p> <p>Schl\u00e4fli symbols use numbers and curly braces to describe a Coxeter group. For example, here are the Schl\u00e4fli symbols for the five platonic solids in 3D:</p> <ul> <li>\\(\\{ 3, 3 \\}\\) = Tetrahedron</li> <li>\\(\\{ 3, 4 \\}\\) = Octahedron</li> <li>\\(\\{ 3, 5 \\}\\) = Icosahedron</li> <li>\\(\\{ 4, 3 \\}\\) = Cube</li> <li>\\(\\{ 5, 3 \\}\\) = Dodecahedron</li> </ul> <p>Exercise</p> <p>If you have any D&amp;D dice lying around, go get them right now and use them to follow along in this next section! \ud83d\udc09</p> <p>The first number in each pair tells you what the base polygon is. For a tetrahedron it's \\(\\{ 3 \\}\\), a triangle. For a cube it's \\(\\{ 4 \\}\\), a square. For a dodecahedron it's \\(\\{ 5 \\}\\), a pentagon. (All of these are regular polygons of course, since we want as much symmetry as possible!)</p> <p>The second number tells you how many of those polygons are situated around a vertex. For the cube, tetrahedron, and dodecahedron, there are three faces around a vertex. For the octahedron, there's four faces around a vertex. For the icosahedron, there's five. You could also think of this as describing the vertex figure of the shape.</p>"},{"location":"hsc/puzzle-dev/geometry/#mirror-structure","title":"Mirror structure","text":"<p>We've already seen how Schl\u00e4fli symbols correspond to shapes, but they're much more general than that.</p> <p>You might wonder how a Coxeter diagram</p>"},{"location":"hsc/puzzle-dev/geometry/#duals","title":"Duals","text":"<p>Notice that the octahedron has the same Schl\u00e4fli symbol as the cube, but reversed. This isn't a coincidence \u2014 the cube and octahedron have the same symmetry! To see this for yourself, hold an octahedron with one vertex facing toward you and a vertex facing up. Now put a vertex in the center of each triangular face and connect them to form a cube.</p> <ul> <li>The 8 triangular faces of the octahedron become the 8 vertices of the cube.</li> <li>The 12 edges of the octahedron become the 12 edges of the cube.</li> <li>The 6 vertices of the octahedron become the 6 square faces of the cube.</li> </ul> <p>We say that the cube and octahedron are dual shapes.</p> <p>Exercise</p> <p>The dodecahedron and icosahedron are also dual. What properties correspond between them?</p> <p>Exercise</p> <p>What's the dual of the tetrahedron?</p>"},{"location":"hsc/puzzle-dev/geometry/#case-study-the-rhombic-dodecahedron","title":"Case study: the rhombic dodecahedron","text":"<p>Let's look at a fun shape: the rhombic dodecahedron.</p> <ul> <li>It has 12 faces, all rhombi.</li> <li>It is face-transitive, meaning the polyhedron can be reoriented to put any face in the place of any other.</li> <li>It is not vertex-transitive. 6 vertices have 3 edges and 8 vertices have 4 edges.</li> </ul> <p>Some of those numbers look familiar ... 6, 8, and 12 showed up in the cube and octahedron. Indeed, the rhombic dodecahedron has cubic symmetry, which is equivalent to octahedral symmetry. The faces of the rhombic dodecahedron correspond to the edges of the cube. We'll come back to this later when we start generating shapes.</p>"},{"location":"hsc/puzzle-dev/geometry/#coxeter-group-names","title":"Coxeter group names","text":"<p>While a cube and an octahedron are different shapes with different Schl\u00e4fli symbols, they have the same symmetry. In fact, you might find yourself building a puzzle like the Corner-Turning Octahedron, which has some elements with cubic symmetry and some with octahedral symmetry. Which Schl\u00e4fli symbol should we use, then?</p> <p>Fear not, for this problem can be solved using even more notation! Every finite Coxeter group has a name. For example, the cubic/octahedral group has the name \\(BC_3\\), which we write as <code>bc3</code> in Lua. See the documentation for the <code>cd()</code> function for the full list. In this case \\(BC_3\\) is the symmetry of the the Schl\u00e4fli symbol \\({ 4, 3 }\\)</p>"},{"location":"infrastructure/server/","title":"Server Setup","text":"<p>As of 2025, there is a DigitalOcean droplet dedicated to the Hypercubing server with the following specs:</p> <ul> <li>RAM: 2 GB</li> <li>Disk: 50 GB</li> <li>Region: SFO3</li> <li>OS: Ubuntu 24.04 (LTS) x64</li> </ul> <p>In the event that this droplet is no longer running, contact HactarCE at hello@ajfarkas.dev.</p> <p>This page contains instructions on how to recreate the server in case it is lost.</p>"},{"location":"infrastructure/server/#nextcloud","title":"Nextcloud","text":"<p>The server runs an instance of Nextcloud which hosts the images for hypercubing.xyz and dev.hypercubing.xyz.</p> <p>All of these commands should be run on the root account of the server. If you haven't already done so, you'll want to generate an SSH key on your local machine and add the public key as a line in <code>~/.ssh/authorized_keys</code>.</p>"},{"location":"infrastructure/server/#install-docker","title":"Install Docker","text":"<pre><code>curl -fsSL https://get.docker.com | sh\n</code></pre>"},{"location":"infrastructure/server/#create-folder-for-nextcloud","title":"Create folder for Nextcloud","text":"<pre><code>mkdir ~/nextcloud\n</code></pre>"},{"location":"infrastructure/server/#configure-caddy","title":"Configure Caddy","text":"<p>Caddy is used as a reverse proxy so that we can run multiple services on the same server accessible at different domains.</p> <p>Save this file as <code>~/nextcloud/Caddyfile</code>:</p> ~/nextcloud/Caddyfile<pre><code>https://assets.hypercubing.xyz:443 {\n    handle_path /* {\n        root * /srv/assets\n        file_server browse\n    }\n}\n\nhttps://cloud.hypercubing.xyz:443 {\n    handle_path /assets/* {\n        root * /srv/assets\n        file_server browse\n    }\n    handle {\n        reverse_proxy * localhost:11000\n    }\n}\n\nhttps://aio.cloud.hypercubing.xyz:443 {\n    reverse_proxy https://localhost:8080 {\n        transport http {\n            tls_insecure_skip_verify\n        }\n    }\n}\n\nhttps://lb.hypercubing.xyz:443 {\n    reverse_proxy localhost:3000\n}\n</code></pre> <p>Note that, because Caddy is running within Docker</p>"},{"location":"infrastructure/server/#configure-docker","title":"Configure Docker","text":"<p>NextCloud and Caddy are run within Docker. We use Docker Compose to run multiple containers easily.</p> <p>Save this file as <code>~/nextcloud/compose.yaml</code>. You may need to change <code>HactarCE/files/assets</code> to some other path; whatever path it is determines the files that will be publicly accessible at assets.hypercubing.xyz.</p> ~/nextcloud/compose.yaml<pre><code>services:\n  nextcloud-aio-mastercontainer:\n    image: docker.io/nextcloud/all-in-one:latest\n    init: true\n    restart: always\n    container_name: nextcloud-aio-mastercontainer # This line is not allowed to be changed as otherwise AIO will not work correctly\n    volumes:\n      - nextcloud_aio_mastercontainer:/mnt/docker-aio-config # This line is not allowed to be changed as otherwise the built-in backup solution will not work\n      - /var/run/docker.sock:/var/run/docker.sock:ro # May be changed on macOS, Windows or docker rootless. See the applicable documentation. If adjusting, don't forget to also set 'WATCHTOWER_DOCKER_SOCKET_PATH'!\n    ports:\n      # - 80:80 # Can be removed when running behind a web server or reverse proxy (like Apache, Nginx, Cloudflare Tunnel and else). See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md\n      - 8080:8080\n      # - 8443:8443 # Can be removed when running behind a web server or reverse proxy (like Apache, Nginx, Cloudflare Tunnel and else). See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md\n    environment: # Is needed when using any of the options below\n      # - AIO_DISABLE_BACKUP_SECTION=false # Setting this to true allows to hide the backup section in the AIO interface. See https://github.com/nextcloud/all-in-one#how-to-disable-the-backup-section\n      - APACHE_PORT=11000 # Is needed when running behind a web server or reverse proxy (like Apache, Nginx, Cloudflare Tunnel and else). See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md\n      - APACHE_IP_BINDING=127.0.0.1 # Should be set when running behind a web server or reverse proxy (like Apache, Nginx, Cloudflare Tunnel and else) that is running on the same host. See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md\n      # - BORG_RETENTION_POLICY=--keep-within=7d --keep-weekly=4 --keep-monthly=6 # Allows to adjust borgs retention policy. See https://github.com/nextcloud/all-in-one#how-to-adjust-borgs-retention-policy\n      # - COLLABORA_SECCOMP_DISABLED=false # Setting this to true allows to disable Collabora's Seccomp feature. See https://github.com/nextcloud/all-in-one#how-to-disable-collaboras-seccomp-feature\n      - NEXTCLOUD_DATADIR=/mnt/ncdata # Allows to set the host directory for Nextcloud's datadir. \u26a0\ufe0f\u26a0\ufe0f\u26a0\ufe0f Warning: do not set or adjust this value after the initial Nextcloud installation is done! See https://github.com/nextcloud/all-in-one#how-to-change-the-default-location-of-nextclouds-datadir\n      # - NEXTCLOUD_MOUNT=/mnt/ # Allows the Nextcloud container to access the chosen directory on the host. See https://github.com/nextcloud/all-in-one#how-to-allow-the-nextcloud-container-to-access-directories-on-the-host\n      # - NEXTCLOUD_UPLOAD_LIMIT=10G # Can be adjusted if you need more. See https://github.com/nextcloud/all-in-one#how-to-adjust-the-upload-limit-for-nextcloud\n      # - NEXTCLOUD_MAX_TIME=3600 # Can be adjusted if you need more. See https://github.com/nextcloud/all-in-one#how-to-adjust-the-max-execution-time-for-nextcloud\n      # - NEXTCLOUD_MEMORY_LIMIT=512M # Can be adjusted if you need more. See https://github.com/nextcloud/all-in-one#how-to-adjust-the-php-memory-limit-for-nextcloud\n      # - NEXTCLOUD_TRUSTED_CACERTS_DIR=/path/to/my/cacerts # CA certificates in this directory will be trusted by the OS of the nexcloud container (Useful e.g. for LDAPS) See See https://github.com/nextcloud/all-in-one#how-to-trust-user-defined-certification-authorities-ca\n      # - NEXTCLOUD_STARTUP_APPS=deck twofactor_totp tasks calendar contacts notes # Allows to modify the Nextcloud apps that are installed on starting AIO the first time. See https://github.com/nextcloud/all-in-one#how-to-change-the-nextcloud-apps-that-are-installed-on-the-first-startup\n      - NEXTCLOUD_STARTUP_APPS=twofactor_totp notes # Allows to modify the Nextcloud apps that are installed on starting AIO the first time. See https://github.com/nextcloud/all-in-one#how-to-change-the-nextcloud-apps-that-are-installed-on-the-first-startup\n      # - NEXTCLOUD_ADDITIONAL_APKS=imagemagick # This allows to add additional packages to the Nextcloud container permanently. Default is imagemagick but can be overwritten by modifying this value. See https://github.com/nextcloud/all-in-one#how-to-add-os-packages-permanently-to-the-nextcloud-container\n      # - NEXTCLOUD_ADDITIONAL_PHP_EXTENSIONS=imagick # This allows to add additional php extensions to the Nextcloud container permanently. Default is imagick but can be overwritten by modifying this value. See https://github.com/nextcloud/all-in-one#how-to-add-php-extensions-permanently-to-the-nextcloud-container\n      # - TALK_PORT=3478 # This allows to adjust the port that the talk container is using. See https://github.com/nextcloud/all-in-one#how-to-adjust-the-talk-port\n      # - WATCHTOWER_DOCKER_SOCKET_PATH=/var/run/docker.sock # Needs to be specified if the docker socket on the host is not located in the default '/var/run/docker.sock'. Otherwise mastercontainer updates will fail. For macos it needs to be '/var/run/docker.sock'\n    # # Uncomment the following line when using SELinux\n    # security_opt: [\"label:disable\"]\n\n  # Optional: Caddy reverse proxy. See https://github.com/nextcloud/all-in-one/blob/main/reverse-proxy.md\n  # You can find further examples here: https://github.com/nextcloud/all-in-one/discussions/588\n  caddy:\n    image: docker.io/caddy:alpine\n    restart: always\n    container_name: caddy\n    volumes:\n      - ./Caddyfile:/etc/caddy/Caddyfile\n      - ./certs:/certs\n      - ./config:/config\n      - ./data:/data\n      - ./sites:/srv\n      - /mnt/ncdata/HactarCE/files/assets:/srv/assets\n    network_mode: \"host\"\n\nvolumes: # If you want to store the data on a different drive, see https://github.com/nextcloud/all-in-one#how-to-store-the-filesinstallation-on-a-separate-drive\n  nextcloud_aio_mastercontainer:\n    name: nextcloud_aio_mastercontainer # This line is not allowed to be changed as otherwise the built-in backup solution will not work\n</code></pre>"},{"location":"infrastructure/server/#start-caddy-nextcloud","title":"Start Caddy + Nextcloud","text":"<pre><code>cd ~/nextcloud\ndocker compose up -d\nsystemctl enable --now docker\n</code></pre>"},{"location":"infrastructure/server/#ensure-the-domain-records-point-to-the-server","title":"Ensure the domain records point to the server","text":"<p>Ensure these domain records exist for <code>hypercubing.xyz</code>, all set to the IP address of the server:</p> Type Name A aio.cloud A assets A cloud <p>And these records for GitHub pages:</p> Type Name Content A hypercubing.xyz 185.199.108.153 A hypercubing.xyz 185.199.109.153 A hypercubing.xyz 185.199.110.153 A hypercubing.xyz 185.199.111.153 CNAME www hypercubers.github.io <p>And these records for other subdomains:</p> Type Name Content CNAME archive hypercubing-archive.gitlab.io CNAME dev hypercubers.github.io <p>If using Cloudflare, proxy status should be set to \"DNS only\" for all of these records.</p>"},{"location":"infrastructure/server/#initialize-nextcloud","title":"Initialize Nextcloud","text":"<p>Go to https://aio.cloud.hypercubing.xyz/. Note the passphrase somewhere safe, then click Open Nextcloud AIO login.</p> <p>If you have access to a backup, save it on the server in <code>/mnt/backup</code> and enter that for Local backup location. Leave Remote borg repo blank. Enter the Borg passphrase saved from when the backup was created.</p>"},{"location":"infrastructure/server/#leaderboards","title":"Leaderboards","text":"<p>The leaderboards are hosted by a single Rust program that controls the Discord bot, database, and web server.</p> <ol> <li>Create a new user: <code>useradd leaderboards</code>.</li> <li>Add your SSH key to <code>/home/leaderboards/.ssh/authorized_keys</code>.</li> <li>SSH into the server as the <code>leaderboards</code> user.</li> <li>Follow the database setup and running instructions in <code>README.md</code> at <code>https://github.com/Hypercubers/hypercubing-leaderboards</code>, including the cron job and useful scripts.</li> </ol>"},{"location":"infrastructure/server/#fancy-command-line-setup","title":"Fancy command line setup","text":"<pre><code># global\nsudo apt install make bat btm cloc eza fd-find fish fzf gh hexyl jq ripgrep sd trash-cli unp zoxide\nsudo snap install zellij --classic\ncurl -sS https://starship.rs/install.sh | sh\n</code></pre> <pre><code># per user, in fish\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource .cargo/env.fish\ncargo install du-dust pfetch\ncurl -sL https://raw.githubusercontent.com/jorgebucaran/fisher/main/functions/fisher.fish | source\nfisher install jorgebucaran/fisher\nfisher install PatrickF1/fzf.fish\nfisher install lewisacidic/fish-git-abbr\nchsh -s /usr/bin/fish\n</code></pre> <p>On local machine with fish shell config:</p> <pre><code>scp -r .config/fish/{config.fish,fish_plugins} &lt;user&gt;@hypercubing:.config/fish/\n</code></pre>"},{"location":"other/guidelines/","title":"Guidelines","text":"<p>Here is a list of guidelines to follow when building puzzle simulators, particularly ones that might be allowed for speedsolves on the Hypercubing leaderboards. Of course, rules are made to be broken, so many of these rules have exceptions.</p>"},{"location":"other/guidelines/#thou-shalt-not-reveal-excess-information","title":"Thou shalt not reveal excess information","text":"<p>Features of the program (piece filters, keybinds, macros, etc.) must not reveal excess information.</p> <p>For example, the X-centers on 4^3 are indistinguishable. If you could make a piece filter that selected individual X-centers, then you could use those to solve centers into their original positions and avoid orientation parity.</p> <p>Exception: Debugging tools may provide this information. These are meant to be used by puzzle designers, not solvers.</p>"},{"location":"other/guidelines/#thou-shalt-not-let-input-handling-know-puzzle-state","title":"Thou shalt not let input handling know puzzle state","text":"<p>User input (via mouse or keyboard) must behave the same way regardless of the current state of the puzzle.</p> <p>If this were not the case, then the user could make a key that simply solves the current case, and pressing a certain sequence of keys repeatedly could solve the puzzle.</p> <p>Exception: The state of which moves are allowed is impossible to hide, so this may be revealed.</p>"},{"location":"other/guidelines/#thou-shalt-not-execute-more-than-one-twist-per-input","title":"Thou shalt not execute more than one twist per input","text":"<p>Each keyboard or mouse input must execute at most one twist.</p> <p>If this were not the case, then the user could make a single key that executes an entire algorithm. This would essentially be a macro, which is undesirable for speedsolving.</p> <p>Exception: If a key is bound to a macro (and the user is not doing a macroless speedsolve) then of coures that key may perform multiple twists.</p>"}]}